# Codebase Context: Architectural Intelligence

> Generated by Gemini Agent at 12/10/2025, 7:28:11 PM

## Research Strategy
The strategy employs a dependency-driven, bottom-up graph traversal. It prioritizes foundational data structures (database entities, common types) as per "The Foundation" heuristic, recognizing that understanding state is prerequisite to understanding logic. This is followed by core application infrastructure (main entry, common utilities, Redis), then critical cross-cutting concerns like authentication and user management. Feature-specific modules are batched subsequently, ensuring their dependencies (e.g., auth, common modules, eventing) are already processed. "The Vertical Slice" heuristic is applied by including associated tests (.spec.ts) alongside their implementations to reveal coupling and verify behavior. Finally, configuration and high-level documentation are processed to provide overall context. This approach ensures that each batch builds upon a well-understood foundation, minimizing forward dependencies and maximizing comprehension of "Load-Bearing Structures."

## Architectural Insights

### Batch: Batch 1: Foundation Layer (Database Entities & Migrations)
**Intent**: Establishes the core data model and persistence layer. These entities define the fundamental data structures of the application, upon which all business logic is built. Understanding these is crucial for comprehending the system's state.

**Files Analyzed**:
- `backend/src/database/entities/conversation.entity.ts`
- `backend/src/database/entities/email-change-request.entity.ts`
- `backend/src/database/entities/index.ts`
- `backend/src/database/entities/invitation.entity.ts`
- `backend/src/database/entities/message.entity.ts`
- `backend/src/database/entities/outbox-event.entity.ts`
- `backend/src/database/entities/project-member.entity.ts`
- `backend/src/database/entities/project.entity.ts`
- `backend/src/database/entities/refresh-token.entity.ts`
- `backend/src/database/entities/two-factor-recovery-code.entity.ts`
- `backend/src/database/entities/user-identity.entity.ts`
- `backend/src/database/entities/user.entity.ts`
- `backend/src/database/entities/visitor.entity.ts`
- `backend/src/database/data-source.ts`
- `backend/src/database/migrations/1765354370752-InitialSchema.ts`

**Insight**:
### AST & CFG Analysis: Foundation Layer

**1. Architectural Topology**
*   **Persistence Strategy**: **TypeORM** with **PostgreSQL**.
*   **Naming Convention**: Enforced via `SnakeNamingStrategy` (Code: `camelCase` -> DB: `snake_case`).
*   **Identifier Strategy**: Hybrid.
    *   **UUID (v4)**: `User`, `RefreshToken`, `UserIdentity`, `Invitation`, `EmailChangeRequest`, `OutboxEvent`.
    *   **BigInt (BigSerial)**: `Conversation`, `Message`, `TwoFactorRecoveryCode`.
    *   **Integer (Serial)**: `Project`, `ProjectMember`, `Visitor`.
*   **Configuration**: `DataSource` initialization validates critical environment variables (`PSQL_HOST`, etc.) before startup, preventing runtime failures due to misconfiguration.

**2. Data Model & Relationships**
*   **Identity & Access Management (IAM)**:
    *   **User**: Central entity. Supports local auth (`passwordHash`) and OAuth (`UserIdentity`).
    *   **Security**: Includes `RefreshToken` (session management), `TwoFactorRecoveryCode` (2FA), and `EmailChangeRequest` (secure workflow).
*   **Multi-Tenancy (Project Scope)**:
    *   **Project**: Root aggregate for tenancy.
    *   **ProjectMember**: Junction table (`User` <-> `Project`) with Role-Based Access Control (`ProjectRole`). Enforces uniqueness on `[userId, projectId]`.
*   **Messaging Domain**:
    *   **Visitor**: Represents an external end-user. Linked to `Project`. Uniquely identified by `visitorUid` (likely client-side generated).
    *   **Conversation**: Scoped to `Project` and `Visitor`. Contains `status` state machine (`OPEN`, `CLOSED`, `PENDING`).
    *   **Message**: Linked to `Conversation`. Stores content and attachments (`jsonb`).
*   **System Reliability**:
    *   **OutboxEvent**: Implements the **Transactional Outbox Pattern**. Stores domain events (`aggregateType`, `payload`) atomically with state changes to ensure eventual consistency with external systems (e.g., message brokers).

**3. State Ownership & Mutation**
*   **Owner**: PostgreSQL is the authoritative state owner.
*   **Mutation**:
    *   **Cascading Deletes**: Aggressively configured. Deleting a `Project` cascades to `Conversations`, `Visitors`, and `Members`. Deleting a `User` cascades to `Identities`, `Tokens`, and `Memberships`.
    *   **Runtime State**: `Visitor.currentUrl` is a non-persistent property, indicating hydration occurs via a separate Redis/Cache layer at runtime.

**4. Migration Analysis (`1765354370752-InitialSchema.ts`)**
*   **Schema Synchronization**: Disabled in `DataSource` (`synchronize: false`), relying entirely on the provided migration file.
*   **Constraint Enforcement**:
    *   Foreign Keys created for most relationships.
    *   **Exception**: `Invitation` table lacks Foreign Key constraints for `project_id` and `inviter_id` in the migration, despite having columns for them.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[INTEGRITY RISK]** - `backend/src/database/entities/invitation.entity.ts`:
    *   **Violation**: Missing Foreign Key Relations. The `Invitation` entity defines `projectId` and `inviterId` as simple columns without `@ManyToOne` decorators or DB-level FK constraints (confirmed in Migration).
    *   **Strategy**: Add `@ManyToOne` relations to `Project` and `User`. Update migration to enforce `FOREIGN KEY` constraints. This prevents orphaned invitations if a project/user is deleted.

2.  **[TYPE SAFETY]** - `backend/src/database/entities/message.entity.ts`:
    *   **Violation**: Ambiguous Primary Key Type. `id: number | string`.
    *   **Strategy**: Standardize on `string` for `bigint` columns in TypeORM to prevent JavaScript integer overflow issues, or use a transformer.

3.  **[DEAD CODE / LEAKY ABSTRACTION]** - `backend/src/database/entities/visitor.entity.ts`:
    *   **Violation**: `currentUrl` property exists on the Entity but is not a column.
    *   **Strategy**: While documented as runtime-populated, this mixes Persistence concerns with DTO/Runtime concerns. Move `currentUrl` to a `VisitorDto` or use `@VirtualColumn` (if supported by specific TypeORM version/extensions) to make the intent explicit.

---

### Batch: Batch 2: Common Types, Decorators & Core Application Setup
**Intent**: Defines shared interfaces and utility types used across the application, along with foundational decorators and the main application entry point and core module. This batch provides essential building blocks and the application's initial configuration.

**Files Analyzed**:
- `backend/src/common/types/authenticated-request.interface.ts`
- `backend/src/common/types/two-factor-request.interface.ts`
- `backend/src/common/decorators/get-current-user.decorator.ts`
- `backend/src/common/decorators/public.decorator.ts`
- `backend/src/common/common.module.ts`
- `backend/src/common/middleware/logger.middleware.ts`
- `backend/src/common/services/encryption.service.ts`
- `backend/src/common/services/encryption.service.spec.ts`
- `backend/src/app.module.ts`
- `backend/src/app.service.ts`
- `backend/src/app.controller.ts`
- `backend/src/app.controller.spec.ts`
- `backend/src/main.ts`
- `backend/src/worker.ts`
- `backend/src/redis/redis.module.ts`

**Insight**:
### AST & CFG Analysis: Core Application & Infrastructure

**1. Architectural Topology & Bootstrapping**
*   **Dual Entry Points**:
    *   **`main.ts`**: Initializes the HTTP Server (Express), WebSocket Gateway (`RedisIoAdapter`), and Swagger documentation.
    *   **`worker.ts`**: Initializes a standalone `ApplicationContext` for the `EventConsumerModule`, decoupling background processing from the HTTP layer.
*   **Process Management**: `main.ts` includes an aggressive `killPort` function using `execSync` to terminate processes on port 3000 before startup.
*   **Module Composition (`AppModule`)**:
    *   **Global Infrastructure**: `ConfigModule` (.env), `TypeOrmModule` (PostgreSQL), `RedisModule` (Pub/Sub), `BullModule` (Queues), `CacheModule` (Redis-backed), `EventEmitterModule` (Internal Bus), `ScheduleModule` (Cron).
    *   **Feature Modules**: Aggregates domain modules (`Auth`, `User`, `Inbox`, `Project`, etc.).

**2. Infrastructure & State Management**
*   **Redis Strategy**:
    *   **Module**: `RedisModule` (Global).
    *   **Topology**: Instantiates two distinct `ioredis` clients: `REDIS_PUBLISHER_CLIENT` and `REDIS_SUBSCRIBER_CLIENT`. This separation is critical for WebSocket scaling and Pub/Sub stability.
    *   **Usage**: Backs `CacheModule`, `BullModule` (Queues), and `RedisIoAdapter` (WebSockets).
*   **Database Configuration**:
    *   **Driver**: Postgres via TypeORM.
    *   **Schema Control**: `synchronize: false` enforces migration-based schema management.
    *   **Naming**: `SnakeNamingStrategy` injected globally.

**3. Security & Cryptography**
*   **Encryption Service**:
    *   **Algorithm**: AES-256-GCM (Authenticated Encryption).
    *   **Key Management**: Derived from `ENCRYPTION_KEY` (must be 32 chars).
    *   **Format**: Stores data as `IV:AuthTag:Ciphertext`.
*   **Context Propagation**:
    *   **Decorators**: `@GetCurrentUser` extracts `req.user`.
    *   **Interfaces**: `AuthenticatedRequest` and `TwoFactorRequest` strictly type the `req.user` object, distinguishing between fully authenticated users and those in a "partial" 2FA state (`partialToken`).

**4. Observability & Middleware**
*   **Logging**: Custom `LoggerMiddleware` intercepts HTTP requests.
    *   **Mechanism**: Monkey-patches `response.send` and `response.json` to capture response bodies for logging.
    *   **Output**: Colorized console logs with duration, status, and error details.
*   **Validation**: Global `ValidationPipe` enabled in `main.ts`.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[STABILITY / PORTABILITY]** - `backend/src/main.ts`:
    *   **Violation**: **OS-Dependent Side Effect**. The `killPort` function uses `execSync` with `lsof` and `kill -9`. This fails on Windows and delegates process management to the application rather than the orchestrator (Docker/K8s/PM2).
    *   **Strategy**: Remove `killPort`. Rely on the deployment environment or scripts (`package.json`) to handle port conflicts.

2.  **[FRAMEWORK IDIOMS / RISK]** - `backend/src/common/middleware/logger.middleware.ts`:
    *   **Violation**: **Monkey-Patching Native Objects**. Overwriting `response.send` and `response.json` is fragile and can conflict with other middleware or compression libraries.
    *   **Strategy**: Replace with a **NestJS Interceptor**. Interceptors have clean access to the response stream (`CallHandler`) via RxJS `tap()` for logging duration and response bodies without modifying the underlying Express response object.

3.  **[OBSERVABILITY]** - `backend/src/common/services/encryption.service.ts`:
    *   **Violation**: **Leaky Logging**. Uses `console.log` inside the constructor for error details regarding key length.
    *   **Strategy**: Inject and use the NestJS `Logger` service. Ensure sensitive key data (even length/fragments) is logged with extreme caution or not at all in production.

4.  **[DEAD CODE / REDUNDANCY]** - `backend/src/app.controller.ts` & `app.service.ts`:
    *   **Violation**: **Boilerplate Artifacts**. The "Hello World" endpoint remains in the codebase.
    *   **Strategy**: Delete `AppController`, `AppService`, and their references in `AppModule`. The API should only expose domain-specific endpoints.

---

### Batch: Batch 3: Authentication Services & Strategies
**Intent**: Focuses on the core logic of user authentication, including service implementations for password management, token handling, OAuth, and the various authentication strategies (local, JWT, Google, 2FA). This is a critical security and access control layer.

**Files Analyzed**:
- `backend/src/auth/auth.module.ts`
- `backend/src/auth/auth.service.ts`
- `backend/src/auth/auth.service.spec.ts`
- `backend/src/auth/services/oauth.service.ts`
- `backend/src/auth/services/password.service.ts`
- `backend/src/auth/services/token.service.ts`
- `backend/src/auth/strategies/2fa-partial-token.strategy.ts`
- `backend/src/auth/strategies/google-link.strategy.ts`
- `backend/src/auth/strategies/google.strategy.ts`
- `backend/src/auth/strategies/jwt.strategy.ts`
- `backend/src/auth/strategies/jwt.strategy.spec.ts`
- `backend/src/auth/strategies/local.strategy.ts`
- `backend/src/auth/strategies/local.strategy.spec.ts`
- `backend/src/auth/strategies/refresh-token.strategy.ts`
- `backend/src/auth/strategies/refresh-token.strategy.spec.ts`

**Insight**:
### AST & CFG Analysis: Authentication Layer

**1. Architectural Topology**
*   **Pattern**: **Facade-Based Orchestration**. `AuthService` acts as the primary entry point, delegating logic to specialized domain services:
    *   `TokenService`: Lifecycle management of JWTs (Access/Refresh) and 2FA Partial tokens.
    *   `PasswordService`: Credential validation and reset workflows.
    *   `OAuthService`: Identity federation (Google) and account linking.
*   **Authentication Flow**:
    *   **Primary**: Dual-token system (Access Token via Header, Refresh Token via HttpOnly Cookie).
    *   **Secondary (2FA)**: Implements an **Intermediate State Pattern**. Login yields a `partialToken` (JWT) if 2FA is enabled, requiring a second exchange via `TwoFactorAuthenticationStrategy`.
    *   **Federated**: OAuth2 via Passport. Supports both "Login" (create/find user) and "Link" (attach provider to existing user) modes via distinct strategies (`GoogleStrategy` vs. `GoogleLinkStrategy`).

**2. Tokenomics & Session Management**
*   **State Persistence**:
    *   **Refresh Tokens**: Stored in PostgreSQL (`RefreshToken` entity). Hashed using `bcrypt` before storage.
    *   **Session Control**: Enforces a strict limit (default: 5) via `TokenService.setCurrentRefreshToken`. Uses a FIFO eviction policy (deletes oldest token when limit reached).
    *   **Revocation**:
        *   **Granular**: Deletion of specific `RefreshToken` row.
        *   **Global**: Updates `User.tokensValidFrom` timestamp. `JwtStrategy` and `RefreshTokenStrategy` reject tokens issued before this timestamp (`iat < tokensValidFrom`).
*   **Performance Bottleneck (Latency Risk)**:
    *   `TokenService.verifyRefreshToken` iterates through *all* active user tokens and executes `bcrypt.compare` sequentially.
    *   **Cost**: `bcrypt` is CPU-bound. With a session limit of 5, a refresh request could incur 5x hashing cost (approx. 500ms+ depending on rounds), blocking the event loop if not offloaded (though `bcrypt` async is used, the cumulative time is high).

**3. Cryptography & Security**
*   **Credential Storage**: `bcrypt` (salt rounds: 12) for passwords and refresh tokens.
*   **Ephemeral Secrets**:
    *   **Verification/Reset Tokens**: 32-byte hex strings (crypto.randomBytes). Stored in Redis (`CacheModule`) with TTL (15m).
    *   **One-Time Codes (OTC)**: Used for OAuth bridging. Stored in Redis (5m TTL).
*   **Defensive Programming**:
    *   `RefreshTokenStrategy` explicitly validates UUID format (Regex) before DB lookup to prevent injection or casting errors.
    *   `AuthService.register` executes inside a transaction to ensure atomicity of User creation and initial settings.

**4. Dependency Graph & Coupling**
*   **High Coupling**: `AuthService` is tightly coupled to `UserService`, `TokenService`, `PasswordService`, `OAuthService`, `MailService`, and `EntityManager`.
*   **Circular Dependency Risk**: `UserModule` imports `AuthModule` (implied by typical NestJS structures, though not explicitly shown in this batch's imports, `AuthModule` imports `UserModule`).
*   **Infrastructure**: Heavy reliance on `CacheModule` (Redis) for flow state (email verification, password reset, OAuth OTC).

---

### [LOG: REFACTORING CANDIDATES]

1.  **[PERFORMANCE / SCALABILITY]** - `backend/src/auth/services/token.service.ts`:
    *   **Violation**: **O(N) Cryptographic Operations**. `verifyRefreshToken` iterates through all user sessions performing `bcrypt.compare`.
    *   **Strategy**: Add a `tokenId` (JTI) to the Refresh Token payload and the Database entity. Perform an O(1) lookup by `tokenId` first, then verify the hash. This eliminates the loop and reduces latency from O(SessionLimit) to O(1).

2.  **[SRP / COHESION]** - `backend/src/auth/auth.service.ts`:
    *   **Violation**: **God Class / Mixed Concerns**. `AuthService` handles registration orchestration, login logic, 2FA routing, and facade methods for password/oauth. It is 300+ lines and growing.
    *   **Strategy**: Extract `RegistrationService` to handle the sign-up transaction (User creation + Email trigger). Extract `LoginService` to handle the credential validation -> token generation pipeline. Keep `AuthService` purely as a controller-facing facade or remove it in favor of injecting specific services.

3.  **[DRY / MAINTENANCE]** - `backend/src/auth/strategies/google.strategy.ts` & `google-link.strategy.ts`:
    *   **Violation**: **Duplicated Configuration**. Both files hardcode the extraction of `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` and the instantiation of the Passport strategy.
    *   **Strategy**: Create a `GoogleConfigFactory` or a base abstract class `BaseGoogleStrategy` that handles the configuration injection, allowing the subclasses to define only the `callbackURL` and `validate` method.

4.  **[OPERATIONAL RISK]** - `backend/src/auth/services/token.service.ts`:
    *   **Violation**: **Implicit Horizontal Scaling Conflict**. The `@Cron` job `handleExpiredTokensCleanup` runs on *every* application instance. In a clustered environment (K8s/Docker Swarm), this causes race conditions and redundant DB load.
    *   **Strategy**: Move the Cron job to a dedicated "Worker" service (already hinted at by `worker.ts` in Batch 2) or implement a distributed lock using Redis (`Redlock`) to ensure only one instance executes the cleanup.

5.  **[TYPE SAFETY]** - `backend/src/auth/strategies/2fa-partial-token.strategy.ts`:
    *   **Violation**: **Magic Strings**. The cookie name `'2fa_partial_token'` and strategy name `'2fa-partial'` are hardcoded strings used across services and strategies.
    *   **Strategy**: Define these as constants in a shared `AuthConstants` file or `ConfigService` to prevent typos and ensure consistency between the TokenService (setter) and Strategy (getter).

---

### Batch: Batch 4: Authentication Controllers, Guards & Two-Factor Authentication
**Intent**: Completes the authentication vertical slice by covering the API endpoints (controllers), access control mechanisms (guards), and the specific implementation for two-factor authentication.

**Files Analyzed**:
- `backend/src/auth/auth.controller.ts`
- `backend/src/auth/auth.controller.spec.ts`
- `backend/src/auth/guards/jwt-auth.guard.ts`
- `backend/src/auth/guards/local-auth.guard.ts`
- `backend/src/auth/guards/refresh-token.guard.ts`
- `backend/src/auth/2fa/two-factor-authentication.controller.ts`
- `backend/src/auth/2fa/two-factor-authentication.controller.spec.ts`
- `backend/src/auth/2fa/two-factor-authentication.service.ts`

**Insight**:
### AST & CFG Analysis: Authentication Controllers & Guards

**1. Architectural Topology**
*   **Layered Security Model**:
    *   **L1 (Transport)**: HTTP Cookies (`httpOnly`, `secure`) transport sensitive tokens (Refresh Token, 2FA Secret, Partial Token).
    *   **L2 (Guards)**: NestJS Guards (`JwtAuthGuard`, `RefreshTokenGuard`, `LocalAuthGuard`) intercept execution context before Controllers, enforcing authentication policies via Passport strategies.
    *   **L3 (Controllers)**: `AuthController` and `TwoFactorAuthenticationController` act as HTTP adapters, managing cookie lifecycles and delegating business logic to `AuthService` and `TwoFactorAuthenticationService`.
*   **2FA State Machine**:
    *   **Phase 1 (Setup)**: `POST /2fa/generate` -> Generates secret -> Encrypts -> Stores in `2fa_secret` Cookie (Client-side state).
    *   **Phase 2 (Activation)**: `POST /2fa/turn-on` -> Decrypts cookie -> Verifies OTP -> Persists to DB -> Clears cookie.
    *   **Phase 3 (Challenge)**: Login -> `2FA_REQUIRED` -> `2fa_partial_token` Cookie -> `POST /2fa/authenticate` -> Verifies OTP -> Issues full tokens.

**2. State Ownership & Mutation**
*   **Ephemeral State (Cookies)**:
    *   `2fa_secret`: Holds the encrypted 2FA secret during setup. Avoids database pollution with unconfirmed secrets.
    *   `2fa_partial_token`: Holds a temporary JWT with limited scope (`2fa-partial`) during the login challenge.
    *   `refresh_token`: Long-lived session credential.
*   **Mutation Points**:
    *   `AuthController.login`: Mutates response object (sets cookies) and potentially throws `UnauthorizedException` with a payload to trigger frontend 2FA flows.
    *   `TwoFactorAuthenticationController.turnOn`: Finalizes state mutation in DB (enables 2FA) and clears temporary cookies.

**3. Security & Cryptography**
*   **Secret Handling**:
    *   2FA secrets are generated via `otplib`.
    *   During setup, the secret is **never** stored in the DB until confirmed. It is encrypted (AES-256 via `EncryptionService`) and stored in a cookie. This prevents "ghost" 2FA setups in the DB.
*   **Token Storage**:
    *   Access Tokens: JSON Response (Memory storage on client).
    *   Refresh Tokens: `HttpOnly` Cookie (Mitigates XSS).
*   **Guard Logic**:
    *   `JwtAuthGuard` checks for `@Public()` decorator override, allowing granular access control.
    *   `RefreshTokenGuard` specifically activates the `jwt-refresh` strategy, isolating the refresh flow.

**4. Control Flow & Error Handling**
*   **Login Flow Branching**:
    *   If `user.isTwoFactorAuthenticationEnabled` is false: Returns 200 OK + Tokens.
    *   If `user.isTwoFactorAuthenticationEnabled` is true: Returns 401 Unauthorized + `errorCode: '2FA_REQUIRED'` + Sets `2fa_partial_token` cookie.
*   **OAuth Linking**:
    *   Uses a `state` parameter (One-Time Code) stored in Redis (`cacheManager`) to prevent CSRF during the Google OAuth linking process.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[ENCAPSULATION VIOLATION]** - `backend/src/auth/auth.controller.ts` (Method: `linkGoogleCallback`):
    *   **Violation**: **Direct Access to Private/Internal Member**. The controller accesses `this.authService['cacheManager']`. This bypasses the service's public API and relies on dynamic property access, breaking type safety and encapsulation.
    *   **Strategy**: Implement a public method in `AuthService` (e.g., `verifyLinkStateToken(state: string): Promise<string>`) that encapsulates the Redis lookup and deletion logic.

2.  **[DRY / MAINTENANCE RISK]** - `backend/src/auth/auth.controller.ts` & `two-factor-authentication.controller.ts`:
    *   **Violation**: **Duplicated Cookie Configuration**. The logic for calculating expiration dates and setting cookie options (`httpOnly`, `secure`, `sameSite`) is repeated 6+ times across two controllers.
    *   **Strategy**: Extract a `CookieService` or a utility function `setAuthCookie(res, name, value, type: 'session' | 'temp')` to centralize security policies (SameSite, Secure) and expiration logic.

3.  **[TYPE SAFETY]** - `backend/src/auth/auth.controller.ts`:
    *   **Violation**: **Magic Strings**. Cookie names `'refresh_token'`, `'2fa_secret'`, `'2fa_partial_token'` are hardcoded strings used in multiple files (Controllers, Tests, Strategies).
    *   **Strategy**: Define a shared `AuthConstants` or `CookieNames` enum (e.g., `CookieRegistry.REFRESH_TOKEN`) to ensure consistency across the application.

4.  **[LOGIC DUPLICATION]** - `backend/src/auth/auth.controller.ts`:
    *   **Violation**: **Redundant Parsing Logic**. The parsing of `JWT_REFRESH_EXPIRES_IN` (e.g., slicing '30d' to '30') occurs in the constructor of `AuthController` and inside `TwoFactorAuthenticationController.authenticate`.
    *   **Strategy**: Move this parsing logic to the `ConfigService` (using a custom getter or transformation) or `TokenService`, so controllers simply request `getRefreshTokenExpiryDate()`.

5.  **[TESTABILITY]** - `backend/src/auth/auth.controller.ts`:
    *   **Violation**: **Hardcoded Redirect URLs**. The `googleAuthRedirect` method constructs redirect URLs using string interpolation with config values.
    *   **Strategy**: While `ConfigService` is used, the construction logic makes testing the exact URL format brittle. Encapsulate URL construction in a helper method or service to allow easier mocking and validation of query parameters.

---

### Batch: Batch 5: User Management & RBAC
**Intent**: Addresses user-related operations and the Role-Based Access Control system, which defines permissions and roles within the application. These modules are fundamental for managing user identities and their capabilities.

**Files Analyzed**:
- `backend/src/user/user.module.ts`
- `backend/src/user/user.service.ts`
- `backend/src/user/user.service.spec.ts`
- `backend/src/user/user.controller.ts`
- `backend/src/user/user.controller.spec.ts`
- `backend/src/rbac/rbac.module.ts`
- `backend/src/rbac/roles.decorator.ts`
- `backend/src/rbac/roles.guard.ts`
- `backend/src/rbac/roles.guard.spec.ts`

**Insight**:
### AST & CFG Analysis: User Management & RBAC

**1. Architectural Topology**
*   **RBAC System (`RbacModule`)**:
    *   **Hybrid Model**: Implements a dual-layer permission system:
        *   **Global Scope**: System-wide roles (`ADMIN` > `USER`).
        *   **Project Scope**: Tenant-specific roles (`MANAGER` > `AGENT`).
    *   **Hierarchy Definition**: Hardcoded `Map` structures within `RolesGuard` define inheritance (e.g., `ADMIN` inherits `USER` permissions).
    *   **Resolution Strategy**: `RolesGuard` inspects metadata (`@Roles`). If a Project Role is required, it dynamically extracts `projectId` from `params`, `query`, or `body` and queries the `ProjectMember` table.
*   **User Domain (`UserModule`)**:
    *   **Monolithic Service**: `UserService` encapsulates all user lifecycle logic: CRUD, Profile Management, Security Settings (2FA), and complex Workflows (Email Change).
    *   **Transaction Boundaries**: High usage of `EntityManager.transaction` ensures atomicity for multi-step operations (e.g., `turnOnTwoFactorAuthentication` updates User and inserts Recovery Codes simultaneously).

**2. State Ownership & Mutation**
*   **Persistence**:
    *   **Primary**: PostgreSQL (`User`, `ProjectMember`, `EmailChangeRequest`, `TwoFactorRecoveryCode`).
    *   **Ephemeral**: Redis (`CacheModule`) used for email verification tokens (`email-change:${token}`) alongside DB persistence.
*   **Critical Mutations**:
    *   **Email Change Workflow**: Implements a "Nuclear Option" security policy. Upon verification:
        1.  Updates `User.email`.
        2.  **Destructive**: Deletes all `UserIdentity` rows (unlinks OAuth providers).
        3.  **Destructive**: Deletes all `RefreshToken` rows (Global Logout).
        4.  **Invalidation**: Updates `tokensValidFrom` to invalidate active JWTs.
    *   **2FA Activation**:
        1.  Encrypts the TOTP secret (AES-256).
        2.  Generates 10 recovery codes, **hashes them** (bcrypt), and stores them. The plaintext codes are returned once and never stored.

**3. Security & Control Flow**
*   **Authorization Logic (`RolesGuard`)**:
    *   **Precedence**: Global Roles check -> Project Roles check.
    *   **Fail-Safe**: If `user` is missing from request, access is denied.
    *   **Logging**: Extensive debug/warn logging for access denial reasons.
*   **Data Sanitization**:
    *   `UserController` manually strips `passwordHash` using object destructuring before returning responses. This is done at the Controller level, not the Entity/DTO level (Serialization).
*   **Input Validation**:
    *   `RolesGuard` attempts to locate `projectId` via heuristic scanning (`params.id` || `params.projectId` || `query` || `body`). This loose coupling increases flexibility but reduces API strictness.

**4. Dependency Graph**
*   **Coupling**:
    *   `RolesGuard` -> `EntityManager`: Direct database dependency inside a Guard.
    *   `UserService` -> `MailService`: Hard dependency for notifications.
    *   `UserService` -> `EncryptionService`: For 2FA secret protection.
*   **Circular Logic**: The `UserService` manages `UserIdentity` (OAuth) deletion, implying domain knowledge of the Auth/OAuth module's data structures.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[PERFORMANCE / LATENCY]** - `backend/src/rbac/roles.guard.ts`:
    *   **Violation**: **N+1 Query Risk in Hot Path**. The guard executes `entityManager.findOne(ProjectMember)` on every request targeting a project-scoped endpoint.
    *   **Strategy**: Implement caching. Store project membership in Redis or include a compressed list of `projectIds` and `roles` in the JWT Access Token (if payload size permits) to avoid DB hits during authorization.

2.  **[SRP / COHESION]** - `backend/src/user/user.service.ts`:
    *   **Violation**: **God Class (400+ lines)**. Handles CRUD, Auth-related security (2FA), and a complex Email Change state machine.
    *   **Strategy**: Extract `UserSecurityService` (2FA, Password) and `EmailChangeService` (Request/Verify flow). Keep `UserService` focused on profile CRUD.

3.  **[SINGLE SOURCE OF TRUTH]** - `backend/src/user/user.service.ts` (Method: `requestEmailChange`):
    *   **Violation**: **Dual State Persistence**. Stores email change token in **both** PostgreSQL (`EmailChangeRequest`) and Redis (`cacheManager.set`).
    *   **Strategy**: Remove Redis storage for this specific feature. The DB entity already has an `expiresAt` column and is queried during verification. Redis adds complexity without significant read-performance benefit for a low-frequency write operation.

4.  **[OPEN/CLOSED PRINCIPLE]** - `backend/src/rbac/roles.guard.ts`:
    *   **Violation**: **Hardcoded Hierarchies**. `globalRoleHierarchy` and `projectRoleHierarchy` are `const` Maps defined inside the file.
    *   **Strategy**: Move role definitions and hierarchies to a configuration file or database table. This allows role modification without recompiling/redeploying the application.

5.  **[API DESIGN / SECURITY]** - `backend/src/rbac/roles.guard.ts`:
    *   **Violation**: **Ambiguous Parameter Resolution**. The guard guesses the location of `projectId` (`params.id`, `params.projectId`, `query`, `body`). This can lead to security bypasses if an attacker injects a conflicting ID in a different transport location (e.g., Body vs Query parameter pollution).
    *   **Strategy**: Enforce a strict convention. Require `projectId` to be a Route Parameter (`@Param('projectId')`) for all project-scoped routes, or use a custom decorator `@ProjectId()` to explicitly bind the source.

6.  **[DATA LEAK RISK]** - `backend/src/user/user.controller.ts`:
    *   **Violation**: **Manual Sanitization**. `passwordHash` is removed manually in the controller methods (`const { passwordHash, ...result } = user`).
    *   **Strategy**: Use `ClassSerializerInterceptor` and `@Exclude()` on the `User` entity or strictly map to a `UserResponseDto`. Manual exclusion is error-prone; adding a sensitive field later requires updating every controller method.

---

### Batch: Batch 6: Eventing System (Producer & Consumer)
**Intent**: Explores the asynchronous event processing infrastructure, including the event producer (BullMQ) and the event consumer with its outbox listener. This reveals how the system handles eventual consistency and background tasks.

**Files Analyzed**:
- `backend/src/event-producer/bullmq-producer.service.ts`
- `backend/src/event-producer/event-producer.module.ts`
- `backend/src/event-consumer/event-consumer.module.ts`
- `backend/src/event-consumer/event-consumer.service.ts`
- `backend/src/event-consumer/event-consumer.service.spec.ts`
- `backend/src/event-consumer/event.processor.ts`
- `backend/src/event-consumer/outbox-listener.service.ts`

**Insight**:
### AST & CFG Analysis: Eventing System (Producer & Consumer)

**1. Architectural Topology**
*   **Asynchronous Decoupling**:
    *   **Mechanism**: **BullMQ** (Redis-backed) decouples the Event Producer (HTTP/Gateway layer) from the Event Consumer (Worker layer).
    *   **Topology**:
        *   **Producer**: `BullMqProducerService` pushes jobs to `live-chat-events-queue`.
        *   **Consumer**: `EventProcessor` (WorkerHost) pulls jobs and delegates to `EventConsumerService`.
*   **Consistency Model**: **Transactional Outbox Pattern**.
    *   **Write Path**: `EventConsumerService` executes a single ACID transaction that:
        1.  Mutates Domain State (`Visitor`, `Conversation`, `Message`).
        2.  Inserts an `OutboxEvent` (Raw SQL).
    *   **Dispatch Path**: `OutboxListenerService` ensures eventual consistency with external systems (Redis Pub/Sub -> WebSocket) by reading the `OutboxEvent` table.
*   **Process Isolation**:
    *   `EventConsumerModule` is configured as a **Root Module** (imports `TypeOrmModule.forRoot`, `ConfigModule.forRoot`). This confirms the existence of a dedicated Worker process (`worker.ts`), separate from the Main API process, allowing independent scaling of background processing.

**2. State Ownership & Mutation**
*   **Persistence**:
    *   **PostgreSQL**: The authoritative source for both Domain Data and the Outbox Queue.
    *   **Redis**: Acts as the ephemeral transport layer for BullMQ (Job Store) and the real-time message bus (`new_message_channel`).
*   **Concurrency Control**:
    *   **Database**: `OutboxListenerService` uses `FOR UPDATE SKIP LOCKED`. This critical locking strategy allows multiple instances of the Outbox Listener to run in parallel (Horizontal Scaling) without processing the same event twice.
    *   **Transaction Scope**: `EventConsumerService.handleNewMessageFromVisitor` wraps 4 distinct write operations (Visitor, Conversation, Message, Outbox) in one `EntityManager.transaction`.

**3. Control Flow & Latency**
*   **Event Ingestion**: `BullMqProducerService.sendMessage` -> Redis (Immediate).
*   **Event Processing**:
    *   `EventProcessor` -> `EventConsumerService.processEvent` -> `handleNewMessageFromVisitor`.
*   **Outbox Dispatch**:
    *   **Trigger**: Hybrid approach.
        1.  **Push**: `pgClient.on('notification')` listens for `outbox_channel`. This implies a database trigger (not shown in code) executes `NOTIFY` on INSERT.
        2.  **Pull**: `setInterval` (60s) acts as a fallback if the `LISTEN` connection drops or the trigger fails.
    *   **Flow**: Lock Rows -> Publish to Redis -> Delete Rows.

**4. Dependency Graph & Coupling**
*   **Infrastructure Leakage**: `OutboxListenerService` bypasses TypeORM to instantiate a raw `pg.Client`. This creates a secondary database connection pool specifically for `LISTEN/NOTIFY`, doubling the connection overhead per worker instance.
*   **Module Coupling**: `EventConsumerModule` is tightly coupled to `InboxModule` (Conversation, Visitor, Message services). This is necessary for the consumer logic but indicates that the `Inbox` domain is not purely isolated to the API.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[ABSTRACTION VIOLATION / TYPE SAFETY]** - `backend/src/event-consumer/event-consumer.service.ts` & `outbox-listener.service.ts`:
    *   **Violation**: **Raw SQL Usage for Entities**. Both services use `manager.query('INSERT INTO outbox_events...')` and `SELECT * FROM outbox_events`.
    *   **Context**: The `OutboxEvent` entity is defined and registered in `TypeOrmModule`.
    *   **Strategy**: Inject `@Repository(OutboxEvent)` or use `manager.getRepository(OutboxEvent)`. Use TypeORM's QueryBuilder or `save/delete` methods. This ensures column name changes in the Entity are reflected in queries and prevents SQL injection risks (though parameterized queries are currently used).

2.  **[DRY / CONFIGURATION DEBT]** - `backend/src/event-consumer/outbox-listener.service.ts`:
    *   **Violation**: **Duplicated Connection Logic**. The service manually instantiates `new Client({...})` using `ConfigService` to fetch host/port/user/pass. This logic duplicates the `TypeOrmModule.forRootAsync` configuration found in `EventConsumerModule`.
    *   **Strategy**: Create a `DatabaseConfigFactory` or export the connection options from a shared config file. Alternatively, access the underlying driver connection from the injected `DataSource` if the driver supports the required listeners, though a dedicated client for `LISTEN` is often safer to avoid blocking the pool.

3.  **[MAINTAINABILITY]** - `backend/src/event-consumer/event-consumer.module.ts`:
    *   **Violation**: **Config Duplication**. The `TypeOrmModule.forRootAsync` configuration is identical to the one likely present in `AppModule` (Batch 2).
    *   **Strategy**: Extract the TypeORM configuration object into a shared `database.config.ts` file. Both `AppModule` and `EventConsumerModule` should import this configuration to ensure the API and Worker always use the same DB settings.

4.  **[TESTING SMELL]** - `backend/src/event-consumer/event-consumer.service.spec.ts`:
    *   **Violation**: **Testing Private Methods**. The test uses `(service as any).handleNewMessageFromVisitor(...)` to test logic.
    *   **Strategy**: The complexity of `handleNewMessageFromVisitor` (Transaction management + 4 service calls) suggests it belongs in a dedicated Domain Service (e.g., `MessageIngestionService`) or Command Handler. Extracting it would make it public and properly testable without casting to `any`.

5.  **[MAGIC STRINGS]** - Global Scope:
    *   **Violation**: **Hardcoded Infrastructure Identifiers**.
        *   Queue: `'live-chat-events-queue'`
        *   Job Name: `'event-job'`
        *   DB Channel: `'outbox_channel'`
        *   Redis Channel: `'new_message_channel'`
    *   **Strategy**: Centralize these in a `SystemConstants` or `InfrastructureConfig` enum. A typo in the string 'outbox_channel' in the DB trigger vs the Node listener would silently break the real-time system.

---

### Batch: Batch 7: Realtime Communication (Gateway & Inbox)
**Intent**: Covers the WebSocket gateway for real-time interactions and the inbox feature, which likely leverages the eventing system and user/message entities. This batch reveals the real-time communication patterns.

**Files Analyzed**:
- `backend/src/gateway/events.gateway.ts`
- `backend/src/gateway/events.gateway.spec.ts`
- `backend/src/gateway/gateway.module.ts`
- `backend/src/gateway/guards/ws-jwt-auth.guard.ts`
- `backend/src/gateway/redis-io.adapter.ts`
- `backend/src/gateway/redis-io.adapter.spec.ts`
- `backend/src/inbox/events.ts`
- `backend/src/inbox/inbox-event.handler.ts`
- `backend/src/inbox/inbox.controller.ts`
- `backend/src/inbox/inbox.controller.spec.ts`
- `backend/src/inbox/inbox.module.ts`
- `backend/src/inbox/services/conversation.service.ts`
- `backend/src/inbox/services/message.service.ts`
- `backend/src/inbox/services/visitor.service.ts`

**Insight**:
### AST & CFG Analysis: Realtime Communication (Gateway & Inbox)

**1. Architectural Topology**
*   **WebSocket Infrastructure**:
    *   **Adapter**: `RedisIoAdapter` extends `IoAdapter` to support horizontal scaling via Redis Pub/Sub (`@socket.io/redis-adapter`).
    *   **Gateway**: `EventsGateway` serves as the unified entry point for both **Agents** (Authenticated via `WsJwtAuthGuard`) and **Visitors** (Anonymous/Identified via `visitorUid`).
    *   **Authentication Strategy**:
        *   **Agents**: JWT in `handshake.auth.token`. Validated against `UserService`.
        *   **Visitors**: Validated in `handleConnection` via `projectId` query param and `Origin` header check against `Project.whitelistedDomains`.
*   **Inbox Domain**:
    *   **Pattern**: Standard Controller-Service-Repository.
    *   **Controller**: `InboxController` exposes HTTP endpoints for Agents to manage conversations (List, Reply, Status Update).
    *   **Event Bridge**: `InboxEventHandlerService` acts as a mediator between:
        *   **Internal Events** (`EventEmitter2`): `visitor.identified`, `visitor.message.received`.
        *   **External Queue** (`BullMqProducerService`): Offloads message persistence/processing.
        *   **Inter-Process Communication** (`Redis Pub/Sub`): Synchronizes real-time messages across multiple API instances.

**2. State Ownership & Mutation**
*   **Ephemeral State (Redis)**:
    *   **Session Map**: `RealtimeSessionService` maintains `visitorUid -> socketId` mappings.
    *   **Context**: Stores `currentUrl` for visitors to provide live context to agents.
    *   **Pub/Sub**: `new_message_channel` broadcasts messages to all gateway instances.
*   **Persistent State (PostgreSQL)**:
    *   **Conversation**: Aggregates messages. Contains status (`OPEN`, `CLOSED`) and unread counts.
    *   **Message**: Immutable record of communication.
    *   **Visitor**: Identity entity.
*   **Mutation Points**:
    *   **Agent Reply**: `MessageService.sendAgentReply` -> DB Insert -> Gateway Emit.
    *   **Visitor Message**: Gateway -> Event Emitter -> `InboxEventHandlerService` -> BullMQ (Async Processing).
    *   **Conversation Status**: `ConversationService.updateStatus` performs transactional updates with RBAC checks.

**3. Security & Control Flow**
*   **Access Control**:
    *   **HTTP**: `InboxController` protected by `JwtAuthGuard` and `RolesGuard` (Requires `AGENT` or `MANAGER` role).
    *   **WebSocket**: `handleConnection` implements a custom firewall. It rejects connections if the `Origin` header does not match the `whitelistedDomains` of the `Project`.
*   **Concurrency**:
    *   **Redis Subscription**: `EventsGateway.afterInit` subscribes to `NEW_MESSAGE_CHANNEL`. When a message arrives, it emits an internal event `redis.message.received`, which `InboxEventHandlerService` consumes to route the message to the specific connected socket.
*   **Data Flow (Visitor Message)**:
    1.  Client emits `sendMessage`.
    2.  Gateway emits `visitor.message.received`.
    3.  Handler pushes to BullMQ (Job: `NEW_MESSAGE_FROM_VISITOR`).
    4.  *Note*: Actual DB persistence happens in the Worker (Batch 6), not here.
*   **Data Flow (Agent Reply)**:
    1.  Agent POSTs to `InboxController`.
    2.  `MessageService` persists message (Status: `SENDING`).
    3.  `MessageService` resolves `visitorSocketId` via `RealtimeSessionService`.
    4.  Gateway emits to Visitor.
    5.  Status updated to `SENT` or `DELIVERED`.

**4. Dependency Graph & Coupling**
*   **High Coupling**: `InboxEventHandlerService` is the nexus point, depending on `ConversationService`, `VisitorService`, `RealtimeSessionService`, `BullMqProducerService`, `EventsGateway`, and `EntityManager`.
*   **Circular Dependency**: `InboxModule` imports `GatewayModule`, and `GatewayModule` imports `ProjectModule` (and likely `InboxModule` indirectly via services). `forwardRef` is used in `ConversationService` to inject `EventsGateway`.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[PERFORMANCE / N+1 QUERY]** - `backend/src/inbox/services/conversation.service.ts` (Method: `listByProject`):
    *   **Violation**: **Iterative I/O**. The method iterates over the fetched conversations and calls `realtimeSessionService.getVisitorCurrentUrl` (Redis GET) for *each* visitor sequentially inside `Promise.all`.
    *   **Strategy**: Implement a bulk retrieval method in `RealtimeSessionService` (e.g., `getManyVisitorCurrentUrls` using Redis `MGET`) to fetch all required data in a single round-trip.

2.  **[SRP / LEAKY ABSTRACTION]** - `backend/src/gateway/events.gateway.ts` (Method: `handleConnection`):
    *   **Violation**: **Business Logic in Transport Layer**. The Gateway manually fetches the Project and validates `whitelistedDomains`. This logic belongs in a Domain Service (e.g., `ProjectSecurityService` or `ProjectService`).
    *   **Strategy**: Extract `validateOrigin(projectId, origin)` to `ProjectService`. The Gateway should only call this method and handle the boolean result.

3.  **[TYPE SAFETY / RUNTIME RISK]** - `backend/src/inbox/inbox-event.handler.ts` (Method: `handleRedisMessageReceived`):
    *   **Violation**: **Unsafe Casting**. `JSON.parse(messageData)` is treated as `any` (implicit) or loosely typed, then destructured. If the Redis message format changes or is corrupted, this will crash the process.
    *   **Strategy**: Define a Zod schema or DTO class-validator for the Redis Pub/Sub payload. Validate the parsed object before accessing properties.

4.  **[HARDCODED CONFIGURATION]** - `backend/src/gateway/redis-io.adapter.ts`:
    *   **Violation**: **Hardcoded CORS Policy**. The `createIOServer` method hardcodes `cors: { origin: true, ... }`.
    *   **Strategy**: Inject CORS configuration via `ConfigService`. In production, `origin: true` (reflect request origin) might be too permissive depending on security requirements.

5.  **[DRY / MAGIC STRINGS]** - `backend/src/gateway/events.gateway.ts`:
    *   **Violation**: **Duplicated Constants**. `NEW_MESSAGE_CHANNEL` is defined locally. This string is likely used in the Worker/Producer logic as well (Batch 6).
    *   **Strategy**: Move shared Redis channel names to a `SharedConstants` library or `InfrastructureConfig` enum to ensure the Producer and Consumer are always synced.

6.  **[ARCHITECTURAL SMELL]** - `backend/src/inbox/services/message.service.ts` (Method: `createMessageAndVerifySent`):
    *   **Violation**: **Misleading Naming / Dead Logic**. The method name implies verification of sending, but it only saves to DB and logs that it "will be sent".
    *   **Strategy**: Rename to `createMessage`. The responsibility of "sending" (publishing to queue) lies with the caller (`EventConsumer`), not this service.

7.  **[TESTABILITY]** - `backend/src/gateway/events.gateway.ts` (Method: `prepareSocketForVisitor`):
    *   **Violation**: **Inline Mapping Logic**. The method manually maps `Conversation` entities to `WidgetMessageDto` inside the gateway.
    *   **Strategy**: Move this mapping logic to a `ConversationMapper` or `MessageDto` static method. This simplifies the Gateway and makes the transformation logic unit-testable in isolation.

---

### Batch: Batch 8: Projects & Mail Services
**Intent**: Examines the project management functionality and the email notification system. These are distinct feature sets that build upon the core user and authentication services.

**Files Analyzed**:
- `backend/src/projects/invitation.service.ts`
- `backend/src/projects/project.controller.ts`
- `backend/src/projects/project.controller.spec.ts`
- `backend/src/projects/project.module.ts`
- `backend/src/projects/project.service.ts`
- `backend/src/projects/project.service.spec.ts`
- `backend/src/projects/public-project.controller.ts`
- `backend/src/mail/email-template.service.ts`
- `backend/src/mail/mail.controller.ts`
- `backend/src/mail/mail.controller.spec.ts`
- `backend/src/mail/mail.module.ts`
- `backend/src/mail/mail.service.ts`
- `backend/src/mail/mail.service.spec.ts`

**Insight**:
### AST & CFG Analysis: Projects & Mail Services

**1. Architectural Topology**
*   **Project Domain**:
    *   **Core Service**: `ProjectService` manages the lifecycle of `Project` and `ProjectMember` entities. It implements a **Transactional Boundary** for creation (Project + Owner Membership) and enforces widget configuration security.
    *   **Invitation System**: `InvitationService` handles the onboarding workflow (`Invitation` entity). It utilizes a **Token-Based State Machine** (Pending -> Accepted/Expired) secured by cryptographic tokens (`crypto.randomBytes`).
    *   **Access Control**:
        *   **Internal**: `ProjectController` uses `RolesGuard` and `JwtAuthGuard` for management.
        *   **Public**: `PublicProjectController` exposes widget settings via a **Fail-Closed** origin validation mechanism (`ProjectService.getWidgetSettings`).
*   **Mail Domain**:
    *   **Infrastructure**: `MailService` wraps `nodemailer` for SMTP transport.
    *   **Templating**: `EmailTemplateService` functions as a **View Layer**, generating HTML strings directly within TypeScript methods.
    *   **Exposure**: `MailController` exposes an endpoint for triggering emails.

**2. State Ownership & Mutation**
*   **Persistence**:
    *   **PostgreSQL**: Stores `Project`, `ProjectMember`, and `Invitation`.
    *   **JSONB**: `Project.widgetSettings` stores configuration (colors, greeting) as a JSON blob, allowing schema-less flexibility for frontend widgets.
*   **Critical Mutations**:
    *   **Project Creation**: Atomic transaction (`ProjectService.create`) ensures a Project never exists without a Manager.
    *   **Invitation Acceptance**: Atomic transaction (`InvitationService.acceptInvitation`) converts an `Invitation` into a `ProjectMember` and updates the invitation status to `ACCEPTED`.
    *   **Widget Settings**: Updates are partial merges (`...project.widgetSettings, ...settingsDto`), preserving existing keys not present in the DTO.

**3. Security & Control Flow**
*   **Origin Validation (CORS++)**:
    *   `ProjectService.getWidgetSettings` implements application-level CORS logic. It strictly validates the `Origin` header against `Project.whitelistedDomains`.
    *   **Policy**: Fail-Closed. If `Origin` is missing or not whitelisted, it returns `null` (Controller throws `ForbiddenException`).
*   **Invitation Security**:
    *   **Identity Binding**: `acceptInvitation` enforces that the authenticated user's email matches the invitation email (`user.email !== invitation.email`). This prevents invitation hijacking but requires users to register with the exact invited email.
    *   **Expiration**: Checks `expiresAt` (7-day window) before processing.
*   **Authorization Redundancy**:
    *   `ProjectController` uses `@Roles(ProjectRole.MANAGER)`.
    *   `InvitationService.createInvitation` *also* manually queries `ProjectMember` to verify the inviter is a `MANAGER`. This is defensive programming but technically redundant given the Guard.

**4. Dependency Graph**
*   **Coupling**:
    *   `ProjectModule` -> `MailModule`: Hard dependency for sending invitations.
    *   `InvitationService` -> `EntityManager`: Direct DB access for complex checks (User existence, Membership existence, Pending invites).
*   **Abstraction Leaks**:
    *   `EmailTemplateService`: The "View" logic (HTML) is hardcoded into the "Service" layer, violating separation of concerns and making content updates require code recompilation.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[SECURITY CRITICAL]** - `backend/src/mail/mail.controller.ts`:
    *   **Violation**: **Open Relay / Unguarded Endpoint**. The `POST /mail/test-send` endpoint has no `@UseGuards()` decorator.
    *   **Risk**: Any external actor can use this API to send spam emails from the system's verified domain, potentially leading to domain blacklisting.
    *   **Strategy**: Remove the controller entirely (if for dev only) or apply `JwtAuthGuard` and `Roles(ADMIN)`.

2.  **[SEPARATION OF CONCERNS]** - `backend/src/mail/email-template.service.ts`:
    *   **Violation**: **Hardcoded Views**. HTML templates are embedded as template literals within TypeScript code.
    *   **Strategy**: Adopt a template engine (Handlebars, EJS, or MJML). Store templates as external assets (`.hbs` files). This decouples content from logic and enables easier editing/localization.

3.  **[ROBUSTNESS / RUNTIME RISK]** - `backend/src/projects/project.service.ts` (Method: `getWidgetSettings`):
    *   **Violation**: **Uncaught Exception Risk**. `new URL(origin)` is called on the `Origin` header. If a client sends a malformed Origin (e.g., `null`, `file://`, or garbage string), this constructor throws an error, causing a 500 Internal Server Error instead of a handled 400/403.
    *   **Strategy**: Wrap `new URL(origin)` in a `try-catch` block. If parsing fails, log a warning and return `null` (Access Denied).

4.  **[ERROR HANDLING]** - `backend/src/mail/mail.service.ts`:
    *   **Violation**: **Error Masking**. The `sendMail` method catches specific transport errors and throws a generic `new Error('Could not send email.')`.
    *   **Risk**: This hides the root cause (e.g., Auth failed, Connection timeout, Quota exceeded) from the caller/logs, making debugging production issues impossible.
    *   **Strategy**: Log the full error stack and re-throw the original error or a custom `MailException` that preserves the cause.

5.  **[DRY / ARCHITECTURE]** - `backend/src/projects/invitation.service.ts`:
    *   **Violation**: **Redundant Authorization Logic**. `createInvitation` manually queries the DB to check if `inviterId` is a `MANAGER`.
    *   **Context**: The `ProjectController` already enforces `@Roles(ProjectRole.MANAGER)`.
    *   **Strategy**: Trust the `RolesGuard`. If the request reaches the service, the user is authorized. Remove the manual DB check to save one query per invitation, or keep it only if the service is intended to be called outside the HTTP context (e.g., CLI/Cron).

---

### Batch: Batch 9: Remaining Feature Modules (Billing, Realtime Session, Screenshot, Usage)
**Intent**: Groups the remaining feature modules, each representing a specific domain of functionality within the application.

**Files Analyzed**:
- `backend/src/billing/billing.module.ts`
- `backend/src/realtime-session/realtime-session.module.ts`
- `backend/src/realtime-session/realtime-session.service.ts`
- `backend/src/realtime-session/realtime-session.service.spec.ts`
- `backend/src/screenshot/screenshot.controller.ts`
- `backend/src/screenshot/screenshot.module.ts`
- `backend/src/screenshot/screenshot.service.ts`
- `backend/src/usage/usage.module.ts`

**Insight**:
### AST & CFG Analysis: Batch 9 (Utilities & Placeholders)

**1. Architectural Topology**
*   **Realtime Session Domain (`RealtimeSessionModule`)**:
    *   **Role**: Specialized State Manager for WebSocket/Visitor associations.
    *   **Infrastructure**: Wraps `RedisModule` (specifically `REDIS_PUBLISHER_CLIENT`) to provide a Key-Value store interface.
    *   **Data Model**:
        *   `session:visitor:{uid}` -> `socketId` (TTL: 3 days).
        *   `session:visitor:{uid}:currentUrl` -> `url` (TTL: 3 days).
*   **Utility Domain (`ScreenshotModule`)**:
    *   **Role**: On-demand micro-service for generating website previews.
    *   **Stack**: NestJS Controller -> Puppeteer (Headless Chrome) -> Redis Cache.
    *   **Security Layer**: Implements Application-Level Firewall (ALF) logic within the Controller to prevent Server-Side Request Forgery (SSRF).
*   **Placeholder Domains**:
    *   `BillingModule` and `UsageModule` are empty classes. They represent reserved architectural slots for future implementation but currently contribute zero runtime logic.

**2. State Ownership & Mutation**
*   **Ephemeral State (Redis)**:
    *   **Session Data**: Owned by `RealtimeSessionService`. High-churn data with strict TTLs.
    *   **Screenshot Cache**: Owned by `ScreenshotService` via `CACHE_MANAGER`. Stores binary image data as Base64 strings (TTL: 60s).
*   **Process State (Memory)**:
    *   **Browser Instance**: `ScreenshotService` maintains a singleton `puppeteer.Browser` handle.
    *   **Lifecycle**: The browser is launched on `onModuleInit` and closed on `onModuleDestroy`. If launch fails (e.g., missing binary), the service enters a "degraded" state (`browserAvailable = false`), preventing crashes but disabling the feature.

**3. Security & Control Flow**
*   **SSRF Defense Strategy (`ScreenshotController`)**:
    *   **Layer 1 (Blocklist)**: Checks hostname against a `Set` of known targets (`localhost`, `metadata.google.internal`).
    *   **Layer 2 (IP Validation)**: Resolves `net.isIP`. If true, parses octets to block Private (`10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`), Link-Local (`169.254.0.0/16`), and Loopback ranges.
    *   **Vulnerability**: The IP validation logic manually splits by `.` (`hostname.split('.')`). This logic **fails completely for IPv6 addresses** (e.g., `fc00::`), as they do not use dot notation, allowing access to internal IPv6 infrastructure.
*   **Concurrency Control**:
    *   **Missing**: `ScreenshotService.getScreenshot` spawns a `browser.newPage()` for every request. There is no semaphore, queue, or pool limit. A burst of requests can exhaust server RAM/CPU, leading to Denial of Service (DoS).

**4. Dependency Graph**
*   **RealtimeSession**: Depends on `RedisModule`.
*   **Screenshot**: Depends on `CacheModule` (Redis) and `Puppeteer` (System Binary).
*   **Coupling**: Low. These modules are leaf nodes in the dependency graph.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[SECURITY CRITICAL]** - `backend/src/screenshot/screenshot.controller.ts` (Function: `isPrivateOrReservedIP`):
    *   **Violation**: **Incomplete Validation Logic (IPv6 Bypass)**. The function relies on `hostname.split('.')` to parse IPs. `net.isIP` returns `6` for IPv6 addresses, but the subsequent logic assumes IPv4 format. Private IPv6 addresses (e.g., `fc00::/7`) bypass this check.
    *   **Strategy**: Use a dedicated library like `ipaddr.js` to parse and validate ranges for both IPv4 and IPv6. Do not implement IP parsing manually.

2.  **[SECURITY / ARCHITECTURE]** - `backend/src/screenshot/screenshot.controller.ts`:
    *   **Violation**: **DNS Rebinding Vulnerability**. The controller validates the *hostname* string, but Puppeteer performs a fresh DNS resolution when navigating. An attacker can use a domain with a short TTL that resolves to a public IP during the check and a private IP during the fetch (TOCTOU).
    *   **Strategy**: Resolve the DNS in the controller, validate the resolved IP, and then force Puppeteer to use that specific IP (e.g., via HTTP Proxy or Host header manipulation), or run the browser in a strictly isolated network namespace (Docker/OS level).

3.  **[PERFORMANCE / DOS RISK]** - `backend/src/screenshot/screenshot.service.ts`:
    *   **Violation**: **Unbounded Concurrency**. `getScreenshot` calls `browser.newPage()` immediately upon request.
    *   **Strategy**: Implement a resource pool (e.g., `puppeteer-cluster`) or a `p-limit` queue to restrict the number of concurrent pages (e.g., max 5). Reject requests when the queue is full.

4.  **[PERFORMANCE / LOGGING]** - `backend/src/realtime-session/realtime-session.service.ts`:
    *   **Violation**: **Excessive Logging in Hot Path**. The service logs "Getting session..." and "Setting session..." for every operation. In a real-time chat application, `getVisitorSession` is called frequently. This will flood logs and degrade I/O performance.
    *   **Strategy**: Downgrade these logs to `verbose`/`debug` level or remove them entirely for read operations.

5.  **[EFFICIENCY]** - `backend/src/screenshot/screenshot.service.ts`:
    *   **Violation**: **Inefficient Storage Format**. Images are converted to Base64 strings before storing in Redis (`buffer.toString('base64')`). This adds ~33% storage overhead and CPU cost for encoding/decoding.
    *   **Strategy**: Store raw `Buffer` directly in Redis (supported by `ioredis` with `Buffer` return type) to save memory and CPU cycles.

6.  **[DEAD CODE]** - `backend/src/billing/billing.module.ts` & `usage/usage.module.ts`:
    *   **Violation**: **Empty Modules**. These files contain no logic.
    *   **Strategy**: Remove them from the codebase until actual implementation begins to reduce noise and compilation time.

---

### Batch: Batch 10: Configuration, Documentation & E2E Tests
**Intent**: Provides context through configuration files, documentation, and high-level end-to-end tests, which validate the integrated system. These files are typically read after the core logic is understood.

**Files Analyzed**:
- `backend/.env.example`
- `backend/.prettierrc`
- `backend/aws/install`
- `backend/aws/README.md`
- `backend/aws/THIRD_PARTY_LICENSES`
- `backend/codebase-context-2025-12-10T08-33-14-476Z.md`
- `backend/compose-backup.yaml`
- `backend/compose.yaml`
- `backend/eslint.config.mjs`
- `backend/GEMINI.md`
- `backend/localstack-init/init-aws.sh`
- `backend/nest-cli.json`
- `backend/package.json`
- `backend/README.md`
- `backend/src/auth/LINK_GOOGLE_ACCOUNT.md`
- `backend/test/app.e2e-spec.ts`
- `backend/test/bullmq.e2e-spec.ts`
- `backend/test/jest-e2e.json`
- `backend/test/tsconfig.json`
- `backend/tsconfig.build.json`
- `backend/tsconfig.json`
- `backend/tsconfig.worker.json`
- `backend/tsconfig.worker.tsbuildinfo`

**Insight**:
### AST & CFG Analysis: Configuration, Infrastructure & E2E Tests

**1. Architectural Topology & Deployment**
*   **Orchestration**: **Docker Compose** (`compose.yaml`) defines the runtime environment.
    *   **Services**: `db` (Postgres 16), `redis` (Redis 7).
    *   **Backup Configuration**: `compose-backup.yaml` defines a full stack including `core` (API), `worker`, and `localstack` (AWS SQS).
    *   **Volume Mounting**: Monorepo structure confirmed via `../..:/usr/src/app` mounts, linking local `shared-dtos` and `shared-types` packages.
*   **Infrastructure Abstraction**:
    *   **AWS Emulation**: `localstack` service configured with `sqs`. Initialization script (`init-aws.sh`) creates a FIFO queue `live-chat-events.fifo` with content-based deduplication.
    *   **Worker Isolation**: `worker` service runs a separate process (`npm run dev:worker`), confirming the decoupled event processing architecture observed in Batch 5.

**2. Configuration & Build Pipeline**
*   **TypeScript Configuration (`tsconfig.json`)**:
    *   **Strictness**: **Compromised**. `noImplicitAny: false` and `strictPropertyInitialization: false` are set. This disables critical compile-time safety checks, allowing `any` types to propagate and uninitialized class properties to cause runtime errors.
*   **Linting (`eslint.config.mjs`)**:
    *   **Policy**: Explicitly turns **OFF** `@typescript-eslint/no-explicit-any`. This indicates a systemic tolerance for loose typing, corroborating the `any` usage seen in Controllers and Gateways.
*   **Environment**:
    *   **Secrets**: `.env.example` outlines required keys. `compose-backup.yaml` contains **Hardcoded Secrets** (e.g., `JWT_SECRET: your_super_secret_jwt_key`), posing a security risk if this file is deployed or used as a base for production.

**3. Testing Strategy**
*   **End-to-End (E2E)**:
    *   **Framework**: Jest + Supertest.
    *   **Integration Logic (`bullmq.e2e-spec.ts`)**: Validates the async event loop (`EventEmitter` -> `BullMQ` -> `Worker` -> `Service`).
    *   **Flakiness**: Relies on `setTimeout(3000)` to wait for the background worker. This is non-deterministic; network latency or CPU load can cause false negatives.
    *   **Mocking**: Overrides `EventConsumerService` to verify execution, effectively testing the *transport* (BullMQ) rather than the *business logic* (DB insertion).

**4. Documentation & Artifacts**
*   **Bloat**: The `backend/aws/` directory contains the raw installation script and licenses for AWS CLI v2. This is binary/installer bloat committed to the source control.
*   **Feature Specs**: `LINK_GOOGLE_ACCOUNT.md` provides a detailed sequence diagram and API contract for the OAuth linking feature, matching the logic found in Batch 3.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[TYPE SAFETY / CRITICAL]** - `backend/tsconfig.json`:
    *   **Violation**: **Compiler Safety Disabled**. `noImplicitAny: false` and `strictPropertyInitialization: false`.
    *   **Strategy**: Enable `strict: true` (or at least these two flags). This will generate build errors that must be resolved, but it prevents a vast class of runtime `undefined` and type mismatch errors.

2.  **[SECURITY / SECRETS]** - `backend/compose-backup.yaml`:
    *   **Violation**: **Hardcoded Secrets**. Contains actual values for `JWT_SECRET`, `ENCRYPTION_KEY`, etc.
    *   **Strategy**: Replace all hardcoded values with `${VARIABLE_NAME}` interpolation. Ensure these values are only sourced from the `.env` file or the host environment.

3.  **[TEST STABILITY]** - `backend/test/bullmq.e2e-spec.ts`:
    *   **Violation**: **Non-Deterministic Wait**. `await new Promise((resolve) => setTimeout(resolve, 3000))`.
    *   **Strategy**: Implement a polling mechanism (e.g., `waitForExpect` or a loop checking the mock call count) with a timeout. This makes tests faster (succeeds immediately) and more reliable.

4.  **[REPO HYGIENE]** - `backend/aws/`:
    *   **Violation**: **Committed Binary Artifacts**. The `install` script and associated license files for AWS CLI are committed to the repo.
    *   **Strategy**: Delete the `backend/aws/` directory. Install AWS CLI via the Dockerfile (using `apk/apt`) or use a pre-built Docker image that includes the CLI if needed for deployment scripts.

5.  **[LINTING STANDARDS]** - `backend/eslint.config.mjs`:
    *   **Violation**: **Suppressed Rules**. `rules: { '@typescript-eslint/no-explicit-any': 'off' }`.
    *   **Strategy**: Remove this override. Enforce explicit typing (`unknown` or specific types) to improve code maintainability and IDE intellisense.

6.  **[BUILD OPTIMIZATION]** - `backend/package.json`:
    *   **Violation**: **Dev Dependency in Runtime Script**. `migration:run` uses `tsx` (TypeScript execution) directly on source files.
    *   **Strategy**: Compile migrations to JavaScript as part of the build process. Run migrations using `typeorm migration:run` against the `dist/` files in production to avoid runtime TypeScript compilation overhead and dependency on `tsx`.

---

## High-Level Summary

# High-Density Architectural Digest: Project Knowledge Graph

**[SYSTEM IDENTITY]**
A **NestJS** monorepo implementing a real-time customer support platform. Architecture relies on **TypeORM (PostgreSQL)** for persistence, **Redis** for ephemeral state/queues, and **Socket.IO** for real-time communication. The system is split into two distinct runtime processes: **API Server** (`main.ts`) and **Background Worker** (`worker.ts`).

---

### 1. Infrastructure & Topology

*   **Runtime Environment**:
    *   **API Node**: Express-based NestJS app. Handles HTTP, WebSockets (`EventsGateway`), and Auth.
    *   **Worker Node**: Standalone NestJS context. Consumes **BullMQ** jobs (`live-chat-events-queue`) for async processing.
    *   **Orchestration**: Docker Compose. Services: `core`, `worker`, `db` (Postgres 16), `redis` (Redis 7), `localstack` (AWS SQS emulation).
*   **Persistence Layer**:
    *   **Primary**: PostgreSQL via TypeORM. `SnakeNamingStrategy`. `synchronize: false` (Migration-driven).
    *   **Cache/PubSub**: Redis via `ioredis`. Used for:
        *   **BullMQ**: Job persistence.
        *   **Socket.IO Adapter**: Horizontal scaling/broadcasts.
        *   **Session Store**: Visitor context & 2FA partial tokens.
        *   **Throttling**: Rate limiting & screenshot caching.
*   **External Dependencies**:
    *   **Puppeteer**: Headless Chrome for `ScreenshotModule`.
    *   **Nodemailer**: SMTP transport.
    *   **Google OAuth**: Passport strategy for identity federation.

---

### 2. Data Model (Entity Relationship Graph)

**Identity & Access (IAM)**
*   **`User`**: Root identity. `uuid`. Contains `passwordHash`, `isTwoFactorEnabled`, `tokensValidFrom` (invalidation timestamp).
*   **`UserIdentity`**: OAuth links (Google). Cascades delete on User.
*   **`RefreshToken`**: Long-lived session. Hashed storage. Linked to User.
*   **`TwoFactorRecoveryCode`**: `BigInt`. Hashed storage.
*   **`Project`**: Tenant root. `int` (Serial). Contains `widgetSettings` (`jsonb`).
*   **`ProjectMember`**: Junction (`User` <-> `Project`). Stores `role` (RBAC).

**Messaging Domain**
*   **`Visitor`**: End-user. `int`. Identified by `visitorUid` (UUID). Runtime property `currentUrl` (hydrated via Redis).
*   **`Conversation`**: `BigInt`. Scoped to `Project` + `Visitor`. Status: `OPEN` | `CLOSED`.
*   **`Message`**: `BigInt`. Immutable. Linked to Conversation. Content + `attachment` (`jsonb`).
*   **`Invitation`**: Pending memberships. **[RISK]** Missing FK constraints in DB schema despite column existence.

**System Reliability**
*   **`OutboxEvent`**: Transactional Outbox Pattern. Stores `aggregateType`, `payload`, `type`.
*   **`EmailChangeRequest`**: Secure workflow state.

---

### 3. Authentication & Security Strategy

**Authentication Flow**
1.  **Credentials**: Email/Password or OAuth (Google).
2.  **2FA Check**:
    *   If Disabled: Issue **Access Token** (JWT) + **Refresh Token** (HttpOnly Cookie).
    *   If Enabled: Issue **Partial Token** (JWT, Cookie: `2fa_partial_token`).
3.  **2FA Verification**: Exchange Partial Token + TOTP for Full Tokens.

**Authorization (RBAC)**
*   **Hybrid Hierarchy**:
    *   **Global**: `ADMIN` > `USER`.
    *   **Project**: `MANAGER` > `AGENT`.
*   **Enforcement**: `RolesGuard`. Dynamically resolves `projectId` from request params/body/query (Heuristic approach).
*   **Session Management**: Strict limit (5 sessions/user). FIFO eviction.

**Cryptography**
*   **Passwords/Tokens**: `bcrypt` (12 rounds).
*   **2FA Secrets**: AES-256-GCM (Encrypted at rest/cookie).
*   **Email Tokens**: `crypto.randomBytes` (Hex).

---

### 4. Eventing & Real-Time Architecture

**Transactional Outbox Pattern**
*   **Write Path**: `EventConsumerService` writes Domain Entity + `OutboxEvent` in a single ACID transaction.
*   **Dispatch Path**: `OutboxListenerService` polls/listens (`FOR UPDATE SKIP LOCKED`) -> Publishes to Redis -> Deletes from DB.

**Message Pipeline (Visitor -> Agent)**
1.  **Ingest**: Visitor emits `sendMessage` (Socket.IO).
2.  **Queue**: Gateway pushes job to `live-chat-events-queue` (BullMQ).
3.  **Process**: Worker (`EventConsumerService`) picks up job -> Transactional Write (DB + Outbox).
4.  **Broadcast**: Outbox Listener detects event -> Redis Pub/Sub (`new_message_channel`).
5.  **Delivery**: API Nodes subscribe to Redis -> Gateway emits to specific connected Agents.

**Message Pipeline (Agent -> Visitor)**
*   **Direct**: Agent POSTs to `InboxController` -> DB Insert -> Gateway Emit (Immediate).

---

### 5. Critical Risks & Technical Debt

**Security Vulnerabilities [HIGH PRIORITY]**
*   **SSRF (ScreenshotModule)**: `isPrivateOrReservedIP` fails on **IPv6**. Logic relies on `split('.')`. DNS Rebinding attack possible (TOCTOU).
*   **Open Relay (MailModule)**: `POST /mail/test-send` is unguarded. Publicly accessible spam vector.
*   **Auth Bypass (RBAC)**: `RolesGuard` guesses `projectId` location. Parameter pollution could bypass checks.
*   **Secrets**: Hardcoded secrets in `compose-backup.yaml`.

**Type Safety & Code Quality**
*   **Strictness Disabled**: `tsconfig.json` has `noImplicitAny: false` and `strictPropertyInitialization: false`.
*   **Linting Suppressed**: `eslint` explicitly allows `any`.
*   **Unsafe Casting**: Redis Pub/Sub payloads are `JSON.parse`'d and cast to `any` without Zod/DTO validation.

**Performance Bottlenecks**
*   **Crypto Latency**: `TokenService.verifyRefreshToken` loops through *all* user sessions performing synchronous `bcrypt.compare`. O(N) cost.
*   **N+1 Queries**: `RolesGuard` queries `ProjectMember` on every project-scoped request.
*   **Unbounded Concurrency**: `ScreenshotService` spawns a new Puppeteer page per request without a pool/queue. DoS risk.

**Architectural Smells**
*   **God Classes**: `AuthService` (300+ lines), `UserService` (400+ lines) mix orchestration, logic, and persistence.
*   **Leaky Abstractions**: `OutboxListener` creates raw `pg.Client` (bypassing TypeORM). `EventsGateway` contains domain logic (Origin validation).
*   **Hardcoded Config**: Magic strings for Redis channels, Queue names, and Cookie names scattered across files.

---

### 6. Global State Management

*   **PostgreSQL**: Authoritative source of truth.
*   **Redis**:
    *   `session:visitor:{uid}`: Maps Visitor UID to Socket ID.
    *   `session:visitor:{uid}:currentUrl`: Runtime context.
    *   `email-change:{token}`: Ephemeral verification state.
*   **Memory**:
    *   `Puppeteer.Browser`: Singleton instance in `ScreenshotService`.
    *   `RoleHierarchy`: Hardcoded Maps in `RolesGuard`.

### 7. Key API Surfaces

*   **`AuthController`**: `/auth/login`, `/auth/register`, `/auth/refresh`. Manages Cookies.
*   **`TwoFactorAuthenticationController`**: `/2fa/generate`, `/2fa/turn-on`, `/2fa/authenticate`.
*   **`InboxController`**: `/inbox/conversations`. Agent interface.
*   **`EventsGateway`**: WebSocket. Namespace `/`. Events: `sendMessage`, `agent.typing`, `visitor.identified`.
*   **`ScreenshotController`**: `/screenshot`. Params: `url`. **[VULNERABLE]**.

