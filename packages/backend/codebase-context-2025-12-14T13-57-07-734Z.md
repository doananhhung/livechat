# Codebase Context: Architectural Intelligence

> Generated by Gemini Agent at 12/14/2025, 8:57:07 PM

## Research Strategy
The batching strategy prioritizes understanding the system's 'Physics' (logic and state) by traversing its dependency graph from foundational data structures upwards to core functionalities and then to auxiliary features. It begins with core data models (entities and common types) as per 'The Foundation' heuristic, followed by database configuration and application bootstrapping. Critical cross-cutting concerns like authentication, user management, and audit logging are then addressed as vertical slices. Subsequently, the asynchronous eventing and real-time communication layers are analyzed, as they are crucial load-bearing structures. Finally, core business domains (projects, inbox, visitors) and external integrations (webhooks), along with other auxiliary features, are covered. This approach ensures that prerequisites are understood before delving into dependent logic, adhering to 'Gall's Law' by building understanding from simpler, core components to more complex, integrated features, while respecting the 30-file batch limit.

## Architectural Insights

### Batch: Batch 1: Core Data Structures (Entities & Common Types)
**Intent**: Ingest all database entity definitions and fundamental common interfaces/types. This establishes the core data model and shared data contracts, which are prerequisites for understanding any business logic.

**Files Analyzed**:
- `src/database/entities/conversation.entity.ts`
- `src/database/entities/email-change-request.entity.ts`
- `src/database/entities/index.ts`
- `src/database/entities/invitation.entity.ts`
- `src/database/entities/message.entity.ts`
- `src/database/entities/outbox-event.entity.ts`
- `src/database/entities/project-member.entity.ts`
- `src/database/entities/project.entity.ts`
- `src/database/entities/refresh-token.entity.ts`
- `src/database/entities/two-factor-recovery-code.entity.ts`
- `src/database/entities/user-identity.entity.ts`
- `src/database/entities/user.entity.ts`
- `src/database/entities/visitor-note.entity.ts`
- `src/database/entities/visitor.entity.ts`
- `src/common/constants.ts`
- `src/common/constants/crypto.constants.ts`
- `src/common/interfaces/request-with-user.interface.ts`
- `src/common/types/authenticated-request.interface.ts`
- `src/common/types/two-factor-request.interface.ts`
- `src/audit-logs/audit.entity.ts`
- `src/canned-responses/entities/canned-response.entity.ts`
- `src/webhooks/entities/webhook-delivery.entity.ts`
- `src/webhooks/entities/webhook-subscription.entity.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Data Model Topology**
The database schema implements a **Hybrid ID Strategy** and **Project-Based Multi-tenancy**.
*   **Identity Domain (UUID)**: Entities related to authentication and security (`User`, `RefreshToken`, `Invitation`, `AuditLog`) utilize `UUID` primary keys to prevent enumeration attacks and ensure global uniqueness.
*   **Operational Domain (BigInt/Int)**: High-volume entities (`Conversation`, `Message`, `Visitor`) utilize `BigInt` or `Increment` primary keys for storage efficiency and indexing performance. `Visitor` implements a dual-ID system: internal `id` (int) for joins, external `visitorUid` (uuid) for public references.
*   **Tenancy**: Strict multi-tenancy is enforced via `projectId` foreign keys on all operational entities (`Conversation`, `Visitor`, `CannedResponse`, `WebhookSubscription`).

**2. Entity Clusters**

*   **Authentication & Identity**:
    *   **`User`**: The aggregate root for identity. Manages `UserIdentity` (OAuth), `RefreshToken` (Session), and `TwoFactorRecoveryCode`.
    *   **`ProjectMember`**: An explicit join entity linking `User` and `Project`, carrying the `ProjectRole`.
    *   **`EmailChangeRequest`**: Securely handles critical state transitions for user identity.

*   **Communication Engine**:
    *   **`Project`**: The tenant root. Contains configuration (`widgetSettings`, `whitelistedDomains`).
    *   **`Conversation`**: The central operational unit. Links `Visitor`, `Project`, and optional `User` (assignee). Tracks state (`status`, `unreadCount`).
    *   **`Message`**: Immutable event records within a conversation. Supports polymorphic content via `jsonb` attachments.
    *   **`Visitor`**: Represents the end-user. Contains a runtime-only property `currentUrl` (hydrated from Redis), demonstrating a **Split-State Architecture** (persistent DB state + ephemeral Redis state).

*   **Infrastructure & Reliability**:
    *   **`OutboxEvent`**: Implements the **Transactional Outbox Pattern**. Decouples database transactions from event bus publishing (BullMQ/Redis), ensuring eventual consistency.
    *   **`AuditLog`**: A polymorphic audit trail (`actorType`, `entityId`) for compliance and debugging.
    *   **`WebhookSubscription` / `WebhookDelivery`**: A dedicated subsystem for external integration, tracking delivery status and payloads.

**3. Key Architectural Patterns**
*   **Transactional Outbox**: The presence of `OutboxEvent` indicates that domain events are persisted in the same transaction as state changes, then processed asynchronously.
*   **Polymorphic Associations**: `AuditLog` and `OutboxEvent` use generic string identifiers (`entityId`, `aggregateId`) to reference entities across the hybrid ID schema.
*   **JSONB Flexibility**: Extensive use of `jsonb` (`metadata`, `widgetSettings`, `attachments`) allows for schema evolution without DDL changes, shifting validation responsibility to the application layer.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[DRY Violation]** - `src/common/types/authenticated-request.interface.ts`:
    *   **Violation**: Redundant definition. Defines `AuthenticatedRequest` which duplicates the purpose of `RequestWithUser` in `src/common/interfaces/request-with-user.interface.ts`.
    *   **Strategy**: Merge into `RequestWithUser`. Standardize on one interface for typed Express requests.

2.  **[Type Safety]** - `src/database/entities/project.entity.ts`:
    *   **Violation**: `widgetSettings` is typed as `IWidgetSettingsDto` but stored as `jsonb` with a default of `{}`.
    *   **Strategy**: Ensure a Value Object or DTO validation layer exists at the repository/service level to enforce the shape of `IWidgetSettingsDto` on write, as Postgres `jsonb` does not enforce TS interfaces.

3.  **[Consistency]** - `src/database/entities/project.entity.ts`:
    *   **Violation**: `Project` uses `increment` (Int32) while `Conversation` uses `bigint` (Int64).
    *   **Strategy**: While 2 billion projects is unlikely, consistent use of `bigint` for all incrementing IDs prevents theoretical overflow and standardizes type handling across the ORM layer.

---

### Batch: Batch 2: Database Configuration and Schema Evolution
**Intent**: Examine the database configuration and migration scripts to understand how the data model is initialized and evolves over time. This provides context for the entities defined in the previous batch.

**Files Analyzed**:
- `src/database/data-source.ts`
- `src/database/database.config.ts`
- `src/database/migrations/1765354370752-InitialSchema.ts`
- `src/database/migrations/1765354370753-AddInvitationForeignKeys.ts`
- `src/database/migrations/1765516134610-SyncEntityChanges.ts`
- `src/database/migrations/1765521915251-AddProjectIdToAuditLog.ts`
- `src/database/migrations/1765524384547-CreateCannedResponse.ts`
- `src/database/migrations/1765549215551-CreateVisitorNote.ts`
- `src/database/migrations/1765605059764-UpdateConversationStatusEnum.ts`
- `src/database/migrations/1765610726351-AddAutoResolveMinutesToProjects.ts`
- `src/database/migrations/1765611059264-AddLastMessageIdToConversations.ts`
- `src/database/migrations/1765637079233-AddMetadataToConversation.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Database Configuration Topology**
The system employs a **Dual-Configuration Strategy** for TypeORM, separating Runtime (App) from CLI (Migrations).
*   **Runtime Configuration (`database.config.ts`)**: Used by NestJS `TypeOrmModule`. Exports a centralized `DATABASE_ENTITIES` array to ensure consistency across the application and worker services. Enforces `synchronize: false` (except in `test` env) to prevent accidental schema mutation in production.
*   **CLI Configuration (`data-source.ts`)**: Used by TypeORM CLI for generating/running migrations. It duplicates the connection logic and, critically, **manually lists entities** instead of importing `DATABASE_ENTITIES`. This creates a **Configuration Drift Risk** where a new entity might be added to the runtime config but missed in the CLI config, leading to missing tables in migrations.

**2. Schema Evolution & Migration Strategy**
The migration history reveals a maturing domain model moving from strict relational structures to hybrid flexible schemas.
*   **Baseline Architecture (`InitialSchema`)**: Establishes the core relational graph. Enforces referential integrity via Foreign Keys with `ON DELETE CASCADE` for child entities (`Messages`, `ProjectMembers`), ensuring no orphaned records.
*   **Transactional Outbox (`OutboxEvent`)**: The schema explicitly supports the Outbox pattern via the `outbox_events` table (`aggregate_type`, `payload: jsonb`). This confirms a distributed system design where database transactions drive event bus consistency.
*   **Polymorphic Auditing (`AuditLog`)**: Introduced in `AddProjectIdToAuditLog`. Uses `entity_id` (string) and `entity` (string) to link audit records to any domain object, bypassing strict Foreign Key constraints in favor of flexibility.
*   **Enum Evolution (`UpdateConversationStatusEnum`)**: Demonstrates the rigidity of Postgres Native Enums. The migration requires breaking the transaction block to execute `ALTER TYPE`, highlighting a complexity trade-off compared to application-level enums.
*   **Denormalization (`AddLastMessageIdToConversations`)**: Adds `last_message_id` to `conversations`. This is a read-optimization (Performance) to avoid expensive joins when fetching conversation lists, shifting complexity to the write path (updating conversation on new message).

**3. Data Integrity & Constraints**
*   **Identity Generation**:
    *   **UUID**: Used for Security/Auth entities (`User`, `RefreshToken`, `Invitation`) and `OutboxEvent`.
    *   **Serial/BigSerial**: Used for Scoped entities (`Project`, `Visitor`, `Conversation`). `Conversation` correctly uses `BIGSERIAL` (Int64) anticipating high volume, while `Project` uses `SERIAL` (Int32).
*   **JSONB Extensibility**:
    *   `Project.widget_settings`: Configuration bag.
    *   `Message.attachments`: Polymorphic content.
    *   `Conversation.metadata`: Added in `AddMetadataToConversation` to allow custom fields without schema changes (e.g., for external CRM integration).

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Single Source of Truth]** - `src/database/data-source.ts`:
    *   **Violation**: The `entities` array is manually defined, duplicating the list in `src/database/database.config.ts`.
    *   **Strategy**: Import `DATABASE_ENTITIES` from `database.config.ts` into `data-source.ts`. This guarantees that the CLI always sees the same entities as the runtime application, preventing missing tables in generated migrations.

2.  **[Database Portability/Rigidity]** - `src/database/migrations/1765605059764-UpdateConversationStatusEnum.ts`:
    *   **Violation**: Usage of Postgres Native Enums (`conversations_status_enum`) forces complex migrations (cannot run inside transactions) and makes `down` migrations lossy or difficult.
    *   **Strategy**: Consider switching to Application-level Enums (stored as `VARCHAR` with Check Constraints or validated in code). This simplifies migrations and allows for easier status workflow changes.

3.  **[Type Consistency]** - `src/database/migrations/1765354370752-InitialSchema.ts`:
    *   **Violation**: `Visitor` uses `SERIAL` (Int32) while `Conversation` uses `BIGSERIAL` (Int64).
    *   **Strategy**: Given that `Visitor` records often scale linearly with `Conversation` records (or faster), `Visitor` IDs should also be `BIGINT` to prevent integer overflow in high-scale deployments.

4.  **[Dead Code / Legacy]** - `src/database/migrations/1765516134610-SyncEntityChanges.ts`:
    *   **Violation**: This migration drops and re-adds constraints on `invitations` immediately after `AddInvitationForeignKeys`.
    *   **Strategy**: In a greenfield or squash scenario, these churn migrations should be coalesced into the `InitialSchema` to reduce migration time and complexity during CI/CD deployment.

---

### Batch: Batch 3: Application Core and Foundational Common Utilities
**Intent**: Analyze the application's entry point, root module, and core common utilities including encryption, logging, and RBAC. This reveals the fundamental architectural patterns and cross-cutting concerns.

**Files Analyzed**:
- `src/main.ts`
- `src/app.module.ts`
- `src/app.controller.ts`
- `src/app.service.ts`
- `src/common/common.module.ts`
- `src/common/services/encryption.service.ts`
- `src/common/decorators/get-current-user.decorator.ts`
- `src/common/decorators/public.decorator.ts`
- `src/common/interceptors/logging.interceptor.ts`
- `src/common/middleware/logger.middleware.ts`
- `src/redis/redis.module.ts`
- `src/rbac/rbac.module.ts`
- `src/rbac/roles.decorator.ts`
- `src/rbac/roles.guard.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Application Runtime Topology**
The application follows a **Monolithic Modular Architecture** with a heavy reliance on Redis as the central nervous system for state distribution.
*   **Bootstrapping (`main.ts`)**:
    *   **Hybrid Transport**: Initializes a standard HTTP server (Express) and a Redis-backed WebSocket adapter (`RedisIoAdapter`), enabling horizontal scaling of WebSocket connections.
    *   **Invasive Middleware**: Registers `LoggerMiddleware` globally, which monkey-patches `response.send` and `response.json` to capture full response bodies for logging.
    *   **Dev-Ops Coupling**: Contains a `killPort(3000)` utility using `execSync` and `lsof`. This is a **Development-Production Parity Violation**, as it executes shell commands that may fail or cause side effects in containerized production environments.

**2. Cross-Cutting Concerns & Infrastructure**
*   **Redis Backbone (`RedisModule`)**:
    *   Configured as a Global Module exporting singleton clients (`REDIS_PUBLISHER_CLIENT`, `REDIS_SUBSCRIBER_CLIENT`).
    *   Serves three distinct architectural functions:
        1.  **Ephemeral State**: `CacheModule` store.
        2.  **Event Bus**: Underlying transport for `BullModule` (Queues) and `RedisIoAdapter` (WebSockets).
        3.  **Permission Caching**: Stores RBAC lookups (`project_member:{projectId}:{userId}`).
*   **Security & Cryptography (`EncryptionService`)**:
    *   Implements **AES-256-GCM** (Authenticated Encryption).
    *   Key Derivation: Directly buffers the `ENCRYPTION_KEY` string.
    *   Storage Format: `iv:authTag:encrypted` (Colon-separated hex strings).
*   **Role-Based Access Control (`RbacModule`)**:
    *   **Hierarchical Model**: Hardcoded inheritance maps (`Admin > User`, `Manager > Agent`).
    *   **Context-Aware Guard (`RolesGuard`)**:
        *   **Hybrid Scope**: Checks Global Roles first, then Project Roles.
        *   **Parameter Binding**: Explicitly binds to `request.params.projectId` or `id`, rejecting query/body parameters to prevent **Parameter Pollution Attacks**.
        *   **Performance**: Implements a "Cache-Aside" pattern using Redis (60s TTL) to prevent database thrashing on every request.

**3. State Ownership & Coupling**
*   **Global Configuration**: `ConfigModule` is global, injecting environment variables into async factory providers (TypeORM, Bull, Redis).
*   **Direct Data Access in Guards**: `RolesGuard` is tightly coupled to the Data Access Layer (`EntityManager`, `ProjectMember` entity). It bypasses the Service Layer, creating a direct dependency between the Authorization layer and the Database schema.
*   **Interceptor vs Middleware**: The system defines both `LoggingInterceptor` (RxJS tap-based) and `LoggerMiddleware` (Monkey-patch based). `main.ts` registers the Middleware, rendering the Interceptor effectively dead code or redundant.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Security/Stability]** - `src/main.ts`:
    *   **Violation**: `killPort` executes shell commands (`lsof`, `kill -9`) unconditionally. This is dangerous in production (permissions, wrong PID) and platform-dependent (Linux/macOS only).
    *   **Strategy**: Wrap execution in `if (process.env.NODE_ENV === 'development')` or remove entirely in favor of proper process management (Docker/PM2).

2.  **[Correctness/Cryptography]** - `src/common/services/encryption.service.ts`:
    *   **Violation**: Validates key length using `secretKey.length !== 32`. This checks character count, not byte length. AES-256 requires exactly 32 bytes. Multi-byte characters in the env var would cause runtime crypto failures despite passing this check.
    *   **Strategy**: Validate using `Buffer.byteLength(secretKey, 'utf-8')`.

3.  **[Architectural Coupling]** - `src/rbac/roles.guard.ts`:
    *   **Violation**: The Guard injects `EntityManager` directly. This leaks database concerns into the HTTP/Auth layer and makes unit testing the Guard difficult without mocking the entire ORM.
    *   **Strategy**: Refactor the project membership lookup into a `ProjectMembershipService` or `PermissionService`. Inject this service into the Guard.

4.  **[Dead Code/Redundancy]** - `src/common/interceptors/logging.interceptor.ts`:
    *   **Violation**: The application uses `LoggerMiddleware` (registered in `main.ts`) for HTTP logging. The `LoggingInterceptor` duplicates this intent but is not globally registered in `AppModule`.
    *   **Strategy**: Delete `LoggingInterceptor` to enforce a Single Source of Truth for logging logic.

5.  **[Implicit Coupling]** - `src/rbac/roles.guard.ts`:
    *   **Violation**: The Guard relies on route parameters being named specifically `projectId` or `id`. If a developer names a parameter `project_id` in the controller, the Guard will fail securely (deny access) but obscurely (logs "No projectId found").
    *   **Strategy**: Define a constant or decorator to explicitly map route parameters to the resource ID expected by the guard, or standardize route naming conventions via linting rules.

---

### Batch: Batch 4: Authentication and Authorization Core
**Intent**: Deep dive into the authentication module, including core services, controllers, guards, and strategies for local, JWT, refresh token, 2FA, and OAuth. This reveals how users are authenticated and authorized across the system.

**Files Analyzed**:
- `src/auth/auth.module.ts`
- `src/auth/auth.controller.ts`
- `src/auth/services/login.service.ts`
- `src/auth/services/password.service.ts`
- `src/auth/services/registration.service.ts`
- `src/auth/services/token.service.ts`
- `src/auth/guards/jwt-auth.guard.ts`
- `src/auth/guards/local-auth.guard.ts`
- `src/auth/guards/refresh-token.guard.ts`
- `src/auth/strategies/jwt.strategy.ts`
- `src/auth/strategies/local.strategy.ts`
- `src/auth/strategies/refresh-token.strategy.ts`
- `src/auth/2fa/two-factor-authentication.controller.ts`
- `src/auth/2fa/two-factor-authentication.service.ts`
- `src/auth/strategies/2fa-partial-token.strategy.ts`
- `src/auth/strategies/google-link.strategy.ts`
- `src/auth/strategies/google.strategy.ts`
- `src/auth/services/oauth.service.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Authentication Topology & State Flow**
The system implements a **Hybrid Authentication Architecture** combining stateless Access Tokens (JWT) with stateful, rotational Refresh Tokens.
*   **Primary Authentication**:
    *   **Local**: `LocalStrategy` delegates to `PasswordService` for bcrypt verification.
    *   **OAuth**: `GoogleStrategy` delegates to `OAuthService` for identity federation and auto-provisioning.
*   **Multi-Factor Authentication (MFA)**:
    *   **State Transition**: Login flows do not issue full tokens immediately if 2FA is enabled. Instead, a **Partial Authority Pattern** is used.
    *   **Partial Token**: A specialized JWT (`is2FA: true`, `isTwoFactorAuthenticated: false`) is issued via `2fa_partial_token` cookie. This token grants access *only* to the 2FA verification endpoint.
    *   **Verification**: `TwoFactorAuthenticationController` consumes the partial token + OTP code to upgrade the session to full authority via `LoginService.loginAfter2FA`.
*   **Session Management**:
    *   **Storage**: Refresh tokens are stored in the database (`RefreshToken` entity) as bcrypt hashes, preventing token theft via database dumps.
    *   **Rotation Strategy**: Implements **Refresh Token Rotation** with a **Grace Period** (20s) to handle race conditions (e.g., concurrent requests from the same client), preventing "infinite logout" loops.
    *   **Session Limiting**: `TokenService` enforces a strict `SESSION_LIMIT` (default 5) per user, evicting the oldest tokens (LRU-like behavior) on new logins.

**2. Security Primitives & Cryptography**
*   **Token Storage**:
    *   **Access Token**: JSON response (Client memory).
    *   **Refresh Token**: `HttpOnly`, `Secure`, `SameSite` Cookie.
    *   **2FA Secrets**:
        *   **At Rest**: Encrypted in DB (`User.twoFactorAuthenticationSecret`).
        *   **In Transit (Setup)**: Encrypted in `2fa_secret` cookie during the setup phase to maintain statelessness between generation and confirmation.
*   **Global Revocation**: The `User` entity contains `tokensValidFrom`. `JwtStrategy` and `RefreshTokenStrategy` check `iat < tokensValidFrom`, allowing instantaneous invalidation of all issued tokens (Logout All / Password Change).
*   **Verification Logic**: `TokenService.verifyRefreshToken` performs a **Linear Scan** of all active user sessions, comparing bcrypt hashes. While secure, this trades CPU cycles for storage security.

**3. Service Granularity & Responsibilities**
*   **`LoginService` (Facade)**: Orchestrates the login process, abstracting the decision tree between "Issue Tokens" vs "Issue Partial 2FA Token".
*   **`OAuthService` (Federation)**: Handles the complexity of linking/unlinking identities and atomic user creation via `EntityManager.transaction`.
*   **`TokenService` (Lifecycle)**: Manages generation, storage, rotation, and cleanup (Cron job) of tokens.
*   **`RegistrationService` (Onboarding)**: Encapsulates user creation, password hashing, and verification email dispatch within a transaction.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[God Class / High Coupling]** - `src/auth/auth.controller.ts`:
    *   **Violation**: The controller injects **9 dependencies** (`RegistrationService`, `LoginService`, `PasswordService`, `OAuthService`, `TokenService`, `EmailChangeService`, `UserService`, `ConfigService`, `Cache`). It handles Registration, Login, Password Reset, OAuth, and Email Verification.
    *   **Strategy**: Decompose into domain-specific controllers: `RegistrationController` (register, verify), `SessionController` (login, logout, refresh), `PasswordController` (forgot, reset, change), and `OAuthController`.

2.  **[Algorithmic Inefficiency]** - `src/auth/services/token.service.ts`:
    *   **Violation**: `verifyRefreshToken` fetches *all* user tokens and iterates through them performing `bcrypt.compare` (expensive CPU operation) until a match is found. With a high `SESSION_LIMIT`, this becomes a DoS vector.
    *   **Strategy**: Include the `refreshTokenId` (UUID) in the JWT payload of the refresh token. Use this ID to fetch the specific record from the DB, then perform a single `bcrypt.compare`.

3.  **[DRY Violation / Security Risk]** - `src/auth/auth.controller.ts` & `src/auth/2fa/two-factor-authentication.controller.ts`:
    *   **Violation**: Cookie configuration logic (`httpOnly`, `secure`, `sameSite`, `expires`) is duplicated across multiple methods (`login`, `refreshTokens`, `authenticate`, `generate`). Inconsistent changes here could lead to security vulnerabilities.
    *   **Strategy**: Centralize cookie generation logic in a `CookieService` or utility factory that enforces consistent security policies based on `NODE_ENV`.

4.  **[Type Safety]** - `src/auth/strategies/refresh-token.strategy.ts`:
    *   **Violation**: Manual regex validation of UUID (`/^[0-9a-f]{8}-.../i`) inside the strategy.
    *   **Strategy**: Utilize `class-validator`'s `isUUID` or a shared validation pipe. The strategy should rely on the framework's validation layer or the ORM's type checking rather than implementing raw regex checks.

5.  **[Implicit Dependency]** - `src/auth/strategies/2fa-partial-token.strategy.ts`:
    *   **Violation**: The strategy manually extracts cookies using a lambda function.
    *   **Strategy**: While functional, `passport-jwt` supports `ExtractJwt.fromExtractors`. The logic is correct but could be cleaner if the cookie name `'2fa_partial_token'` was a constant shared with the Controller to prevent magic string drift.

---

### Batch: Batch 5: User Management and Audit Logging
**Intent**: Examine the user management module, including user CRUD operations and security-related services. Concurrently, analyze the audit logging system to understand how critical actions are tracked, providing insight into system accountability.

**Files Analyzed**:
- `src/users/user.module.ts`
- `src/users/user.controller.ts`
- `src/users/user.service.ts`
- `src/users/services/email-change.service.ts`
- `src/users/services/user-security.service.ts`
- `src/audit-logs/audit.module.ts`
- `src/audit-logs/audit.controller.ts`
- `src/audit-logs/audit.service.ts`
- `src/audit-logs/audit.interceptor.ts`
- `src/audit-logs/audit.utils.ts`
- `src/audit-logs/auditable.decorator.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Audit Subsystem Topology (AOP Architecture)**
The Audit system implements an **Aspect-Oriented Programming (AOP)** pattern using NestJS Interceptors and Decorators to decouple compliance logging from business logic.
*   **Metadata-Driven**: The `@Auditable` decorator injects metadata (`action`, `entity`) into the execution context.
*   **Interceptor Logic (`AuditLoggerInterceptor`)**:
    *   **Context Extraction**: Inspects `RequestWithUser` to identify the actor.
    *   **Heuristic ID Resolution**: Attempts to resolve `projectId` via parameter sniffing (`params.projectId` vs `body.projectId`) and `entityId` via response inspection. This creates a **Brittle Coupling** to the HTTP interface shape.
    *   **Fail-Open Design**: The interceptor catches logging errors explicitly to ensure that audit infrastructure failures do not block the main business transaction.
    *   **Sanitization**: Implements recursive redaction (`sanitizeMetadata`) to prevent PII/Secrets leakage into logs, utilizing a blocklist (`DEFAULT_SENSITIVE_KEYS`).

**2. User Security & State Transitions**
The User module enforces **High-Friction Security Flows** for critical identity mutations.
*   **Email Change Protocol (`EmailChangeService`)**:
    *   **State Machine**: `Request` (Pending) -> `Verify` (Confirmed) -> `Cleanup`.
    *   **Security Gates**: Requires `currentPassword` verification (Re-authentication) and ensures the new email is unique.
    *   **Session Termination**: Upon success, explicitly invalidates **all** sessions (`RefreshToken`) and unlinks OAuth identities (`UserIdentity`) to prevent account takeover persistence.
    *   **Dual-State Storage**: Uses Postgres (`EmailChangeRequest`) for persistence and Redis (`email-change:{token}`) for fast token lookup, though the redundancy suggests a potential consistency gap if one fails.
*   **Two-Factor Authentication (`UserSecurityService`)**:
    *   **Zero-Knowledge Storage**: Recovery codes are stored as **Bcrypt Hashes**, not plain text. This prevents support staff or attackers with DB access from viewing valid codes.
    *   **Verification Cost**: Validating a recovery code requires a **Linear Scan** (`O(N)`) of all user codes, performing expensive `bcrypt.compare` operations for each.

**3. Data Ownership & Privacy**
*   **`User` Entity**: Acts as the Aggregate Root. The controller manually strips `passwordHash` before serialization, indicating a lack of a centralized **View Model / Serialization Layer**.
*   **`AuditLog` Entity**: An immutable, append-only ledger. It uses **Weak References** (string `entityId`) rather than Foreign Keys to allow auditing of deleted entities and avoid circular dependencies.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Performance/DoS Vector]** - `src/users/services/user-security.service.ts`:
    *   **Violation**: `verifyAndConsumeRecoveryCode` iterates through all recovery codes (default 10) and performs `bcrypt.compare` on each. Bcrypt is CPU intensive (~100ms). A valid login attempt could take ~1 second; an invalid one definitely takes ~1 second.
    *   **Strategy**: Store recovery codes as `sha256(code + salt)` (fast hash) instead of bcrypt. Recovery codes are high-entropy random strings, making them resistant to rainbow tables without the need for work-factor delays.

2.  **[Brittle Logic / Implicit Coupling]** - `src/audit-logs/audit.interceptor.ts`:
    *   **Violation**: The `projectId` extraction logic (`params.projectId || body.projectId`) is heuristic and fragile. It assumes specific naming conventions in Controllers.
    *   **Strategy**: Standardize `projectId` location (e.g., always in `params` or a specific header) or allow the `@Auditable` decorator to define a `projectIdExtractor` function, similar to `entityIdExtractor`.

3.  **[Data Leakage Risk]** - `src/users/user.controller.ts`:
    *   **Violation**: Manual removal of `passwordHash` (`const { passwordHash, ...result } = user`) is repeated in `getProfile` and `updateProfile`. If a new endpoint is added and this manual step is forgotten, password hashes will leak.
    *   **Strategy**: Use NestJS `ClassSerializerInterceptor` with `@Exclude()` on the `User` entity's `passwordHash` property to enforce stripping at the framework level.

4.  **[Hardcoded Configuration]** - `src/audit-logs/audit.utils.ts`:
    *   **Violation**: `DEFAULT_SENSITIVE_KEYS` is a hardcoded `Set`. It misses common variations (e.g., `access_token`, `api_key`) and cannot be updated without code changes.
    *   **Strategy**: Move sensitive keys list to `ConfigService` or a dedicated configuration file, allowing environment-specific redaction rules.

5.  **[Business Logic Gap]** - `src/users/services/email-change.service.ts`:
    *   **Violation**: `requestEmailChange` throws `BadRequestException` if `!user.passwordHash`. This effectively blocks OAuth-only users (who have no password) from changing their email address.
    *   **Strategy**: Implement a conditional check. If the user has no password (OAuth-only), require a re-authentication via the OAuth provider or skip the password check, rather than blocking the action entirely.

---

### Batch: Batch 6: Event Production and Consumption System
**Intent**: Analyze the core eventing infrastructure, including the event producer (BullMQ) and the event consumer, along with the outbox pattern implementation. This reveals the asynchronous communication patterns and how background tasks are processed.

**Files Analyzed**:
- `src/event-producer/event-producer.module.ts`
- `src/event-producer/bullmq-producer.service.ts`
- `src/event-consumer/event-consumer.module.ts`
- `src/event-consumer/event-consumer.service.ts`
- `src/event-consumer/event.processor.ts`
- `src/event-consumer/outbox-listener.service.ts`
- `src/event-consumer/outbox.persistence.service.ts`
- `src/worker.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Event Processing Topology**
The system implements a **Reliable Asynchronous Event Pipeline** utilizing a "Queue-Worker-Outbox" triad to ensure data consistency and scalability.
*   **Ingestion Layer (BullMQ)**: `BullMqProducerService` pushes jobs to a Redis-backed queue (`live-chat-events-queue`). This decouples the ingestion rate from processing capacity.
*   **Processing Layer (Worker)**: `EventProcessor` consumes jobs and delegates to `EventConsumerService`. This service executes complex domain logic (Visitor/Conversation resolution) within a strict **ACID Transaction**.
*   **Propagation Layer (Transactional Outbox)**:
    *   **Write Side**: Inside the processing transaction, an `OutboxEvent` is persisted, and a Postgres `NOTIFY` signal is emitted. This guarantees that the event is only published if the database transaction commits (Atomicity).
    *   **Read Side**: `OutboxListenerService` employs a **Hybrid Listen/Poll Strategy**. It listens to Postgres channels for low-latency updates and falls back to polling (60s) for reliability.
    *   **Distribution**: Processed outbox events are published to Redis (`NEW_MESSAGE_CHANNEL`) for real-time consumption (e.g., by WebSocket servers) and then hard-deleted.

**2. Concurrency & Locking Mechanisms**
*   **Pessimistic Locking**: `OutboxPersistenceService` utilizes `FOR UPDATE SKIP LOCKED` via raw SQL. This is a critical architectural decision that allows multiple instances of the `OutboxListenerService` to run concurrently without processing the same event twice, enabling horizontal scaling of the event dispatcher.
*   **Dual-Connection Strategy**: `OutboxListenerService` instantiates a raw `pg.Client` separate from the TypeORM `DataSource`. This is necessary because TypeORM's connection pool is designed for request/response cycles, whereas `LISTEN` requires a dedicated, long-lived connection.

**3. Data Integrity & Coupling**
*   **Implicit Schema Dependency**: `OutboxPersistenceService` relies on raw SQL (`SELECT * FROM outbox_events`, `DELETE FROM outbox_events`). This bypasses TypeORM's metadata layer, creating a **High Coupling** to the specific table name. If the entity is renamed or the table prefix changes, this service will fail at runtime.
*   **Magic String Construction**: `EventConsumerService` constructs `recipientId` as `` `project_${projectId}` ``. This logic embeds domain knowledge about ID formats directly into the service layer, violating the Single Responsibility Principle regarding identity generation.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Configuration Drift / DRY Violation]** - `src/event-consumer/outbox-listener.service.ts`:
    *   **Violation**: Manually instantiates a `pg.Client` using `PSQL_HOST`, `PSQL_PORT`, etc. This duplicates the connection logic found in `database.config.ts` (which likely uses `DATABASE_HOST` etc.).
    *   **Strategy**: Centralize database connection configuration. Inject the raw connection options from a shared `DatabaseConfigService` to ensure the listener connects to the same database as the application, respecting the same environment variables.

2.  **[Leaky Abstraction / Maintenance Risk]** - `src/event-consumer/outbox.persistence.service.ts`:
    *   **Violation**: Uses raw SQL (`DELETE FROM outbox_events`) for deletion.
    *   **Strategy**: Use TypeORM's `QueryBuilder` or `repository.delete()` where possible. For `SKIP LOCKED` (which TypeORM supports partially or via specific locking modes), encapsulate the query builder logic to use the Entity metadata (`this.outboxRepository.metadata.tableName`) instead of hardcoded strings.

3.  **[Process Management]** - `src/worker.ts`:
    *   **Violation**: Uses `await new Promise(() => {})` to keep the process alive. This creates a pending promise that never resolves, which is a "hacky" way to prevent process exit and can interfere with graceful shutdown signals (SIGTERM).
    *   **Strategy**: Rely on NestJS lifecycle hooks. The `BullMQ` worker keeps the event loop active. If explicit keep-alive is needed, use a proper signal handler or `app.listen()` on a management port (e.g., for health checks).

4.  **[Type Safety / Magic Strings]** - `src/event-consumer/event-consumer.service.ts`:
    *   **Violation**: Hardcoded string interpolation `` `project_${projectId}` `` for `recipientId`.
    *   **Strategy**: Move this logic to a static factory method on the `Message` entity or a dedicated `IdentityService` (e.g., `IdentityService.getProjectRecipientId(projectId)`). This centralizes the ID format definition.

5.  **[Resource Management]** - `src/event-consumer/outbox-listener.service.ts`:
    *   **Violation**: The `pgClient` is created in `onModuleInit` but error handling during connection is just logged. If the DB is temporarily unavailable on startup, the listener might fail silently or leave the service in a degraded state without retrying.
    *   **Strategy**: Implement a retry mechanism with exponential backoff for the initial connection and the `LISTEN` command to ensure resilience against transient database unavailability.

---

### Batch: Batch 7: Realtime Communication Gateway
**Intent**: Examine the WebSocket gateway and related components, including DTOs, guards, and the Redis adapter, along with the realtime session management. This clarifies how real-time interactions and persistent sessions are handled.

**Files Analyzed**:
- `src/gateway/gateway.module.ts`
- `src/gateway/events.gateway.ts`
- `src/gateway/dtos/gateway.dto.ts`
- `src/gateway/guards/ws-jwt-auth.guard.ts`
- `src/gateway/redis-io.adapter.ts`
- `src/realtime-session/realtime-session.module.ts`
- `src/realtime-session/realtime-session.service.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Realtime Architecture & Topology**
The system implements a **Stateful Gateway Pattern** using Socket.IO backed by Redis for horizontal scalability.
*   **Distributed Event Bus**: The `RedisIoAdapter` enables a **Publish-Subscribe** mechanism across multiple gateway instances. Events emitted to a room (e.g., `project:{id}`) are propagated via Redis to all instances holding relevant sockets.
*   **Hybrid Authentication Strategy**:
    *   **Agents**: Authenticated via JWT in the handshake (`auth.token`). The `WsJwtAuthGuard` and `handleConnection` enforce token validity and revocation checks (`tokensValidFrom`).
    *   **Visitors**: Authenticated implicitly via `projectId` and **Origin Validation** (CORS-like check against `whitelistedDomains`).
*   **Event Ingestion**: The Gateway acts as an ingress point, converting WebSocket frames into internal domain events via `EventEmitter2` (e.g., `visitor.identified`, `visitor.message.received`), decoupling the transport layer from business logic.

**2. Session & State Management**
*   **Ephemeral State (Redis)**: `RealtimeSessionService` manages visitor presence and context.
    *   **Presence**: `session:visitor:{uid}` maps Visitor UID to Socket ID.
    *   **Context**: `session:visitor:{uid}:currentUrl` stores the visitor's active page.
    *   **Concurrency Control**: The `deleteVisitorSession` method implements a **Compare-and-Delete** strategy. It only removes the session if the stored Socket ID matches the disconnecting Socket ID, preventing race conditions where a rapid reconnect (new socket) is accidentally killed by the processing of the old socket's disconnect event.
*   **Socket State (In-Memory)**: The `client.data` object serves as a localized session store, caching `user` (Agent), `visitorUid`, `projectId`, and `conversationId`. This reduces database lookups for subsequent events on the same connection.

**3. Coupling & Cohesion Analysis**
*   **The "God Class" Gateway**: `EventsGateway` exhibits **Low Cohesion** and **High Coupling**.
    *   **Dependencies**: Injects 11 services, including `EntityManager`, `Redis`, `ConfigService`, and multiple domain services (`ProjectService`, `UserService`, `VisitorsService`, `ConversationService`).
    *   **Responsibilities**: It handles connection lifecycle, authentication, input validation, event routing, Redis subscription, *and* direct database mutations (`handleUpdateContext` modifies `Conversation` entities).
*   **Circular Dependencies**: The module explicitly uses `forwardRef` for `InboxModule` and `VisitorsModule`. This indicates that the Gateway is not just a passive consumer of events but is deeply entangled with the domain logic that also needs to emit events back to the Gateway.

**4. Data Integrity & Persistence**
*   **Lazy Initialization**: The system supports "Lazy Conversation Creation". A visitor can connect and navigate (sending `UPDATE_CONTEXT`) without a conversation existing. The Gateway attempts to resolve `conversationId` on the fly or caches it once created.
*   **Direct Entity Access**: The `handleUpdateContext` method bypasses the Service Layer, using `EntityManager` to fetch, modify, and save `Conversation` entities directly. This scatters business logic (URL history truncation, metadata updates) into the transport layer.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[SRP Violation / High Coupling]** - `src/gateway/events.gateway.ts`:
    *   **Violation**: The Gateway class is overloaded (11 dependencies). It performs direct database operations in `handleUpdateContext` (fetching/saving `Conversation`, managing `urlHistory`).
    *   **Strategy**: Extract business logic. Move the `handleUpdateContext` logic into `ConversationService.updateContext(conversationId, url)`. The Gateway should only parse the payload and delegate to the service.

2.  **[Type Safety]** - `src/realtime-session/realtime-session.service.ts`:
    *   **Violation**: Usage of `(this.redis as any).mget(keys)`. Casting the Redis client to `any` bypasses TypeScript checks and suggests a mismatch between the installed `redis` types and usage.
    *   **Strategy**: Use the correct type definition for `RedisClientType` or ensure the method signature matches the library version. Avoid `any` casting on core infrastructure components.

3.  **[Architectural Cycle]** - `src/gateway/gateway.module.ts`:
    *   **Violation**: Usage of `forwardRef(() => InboxModule)` and `forwardRef(() => VisitorsModule)`. This indicates a circular dependency where Domain Modules depend on the Gateway (to emit), and the Gateway depends on Domain Modules (to validate/persist).
    *   **Strategy**: Decouple using an **Event Bus**. Domain modules should emit events (e.g., via `EventEmitter2` or Redis) that the Gateway subscribes to, rather than injecting the Gateway service directly. Alternatively, introduce a `NotificationService` interface implemented by the Gateway and injected into domain modules.

4.  **[Configuration Drift]** - `src/gateway/redis-io.adapter.ts`:
    *   **Violation**: Manually constructs the Redis connection string (`redis://${redisHost}:${redisPort}`). This logic likely duplicates configuration found in `database.config.ts` or `redis.module.ts`.
    *   **Strategy**: Centralize Redis configuration. Inject a `RedisConfigService` or reuse the existing `RedisModule` connection options to ensure consistency (e.g., handling passwords, TLS, or DB indexes) across the application.

5.  **[Magic Strings]** - `src/gateway/events.gateway.ts`:
    *   **Violation**: `NEW_MESSAGE_CHANNEL` is defined as a local constant string. If the publisher (likely in `InboxModule` or `EventProducer`) uses a slightly different string, the system fails silently.
    *   **Strategy**: Move shared channel names to a shared constants file (e.g., `@live-chat/shared-types` or a `constants.ts` file in `common`) to guarantee contract safety between Publisher and Subscriber.

6.  **[Inconsistent Error Handling]** - `src/gateway/events.gateway.ts`:
    *   **Violation**: `handleConnection` manually disconnects the client (`client.disconnect(true)`) on auth failure, while `WsJwtAuthGuard` throws `WsException`.
    *   **Strategy**: Standardize on one approach. Since `handleConnection` is the initial handshake, the manual disconnect is valid, but the logic for token verification is duplicated between the handler and the guard. Extract token verification into a reusable `AuthHelperService`.

---

### Batch: Batch 8: Project Management Core
**Intent**: Focus on the project management module, including controllers, services, DTOs, and invitation logic. This provides insight into how projects are created, managed, and shared within the system.

**Files Analyzed**:
- `src/projects/project.module.ts`
- `src/projects/project.controller.ts`
- `src/projects/project.service.ts`
- `src/projects/public-project.controller.ts`
- `src/projects/dto/create-project.dto.ts`
- `src/projects/invitation.service.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Project Management Topology**
The module implements a **Hierarchical Multi-Tenant Architecture** where `Project` serves as the tenant root.
*   **Membership Model**: Many-to-Many relationship between `User` and `Project` resolved via the explicit join entity `ProjectMember`. This entity carries the `ProjectRole` (RBAC), allowing users to have different privileges across different projects.
*   **Invitation System**: Implements a **Secure Token Exchange** pattern.
    *   **State**: `Invitation` entity tracks lifecycle (`PENDING`, `ACCEPTED`, `EXPIRED`).
    *   **Security**: Binds invitations to a specific email address. The `acceptInvitation` method enforces a **Identity Binding Check** (`user.email !== invitation.email`), preventing token hijacking where an attacker intercepts a link and accepts it with their own account.
    *   **Atomicity**: Acceptance is wrapped in a transaction (`ProjectMember` creation + `Invitation` status update) to prevent race conditions or partial failures.

**2. Security & Access Control**
*   **Origin-Based Access Control (OBAC)**:
    *   `ProjectService.getWidgetSettings` implements strict **CORS-like enforcement** at the application layer.
    *   **Fail-Closed Logic**: Explicitly rejects requests missing the `Origin` header or if the project has no whitelisted domains.
    *   **Validation**: Parses the `Origin` header using the `URL` API and matches the hostname against `whitelistedDomains`. This prevents unauthorized embedding of the chat widget.
*   **Dual-Layer Authorization**:
    *   **Layer 1 (Guard)**: `RolesGuard` (from previous batches) protects routes at the HTTP level.
    *   **Layer 2 (Service)**: `ProjectService.validateProjectMembership` performs a secondary DB lookup to fetch the project and re-verify access. While secure (Defense in Depth), this introduces a **Redundant Read Operation** on every protected request.

**3. Data Consistency & Mutation**
*   **Transactional Boundaries**:
    *   **Project Creation**: `ProjectService.create` wraps `Project` insertion and `ProjectMember` (Manager) assignment in a single transaction.
    *   **Invitation Acceptance**: `InvitationService.acceptInvitation` ensures that a user is not added to a project unless the invitation is successfully marked as consumed.
*   **DTO Validation**: `CreateProjectDto` uses strict regex (`Matches`) to enforce FQDN format for whitelisted domains, rejecting protocols (`http://`) to simplify downstream comparison logic in `getWidgetSettings`.

**4. Service Responsibilities**
*   **`ProjectService`**: Acts as a **God Service** for the domain. It manages Project lifecycle, Widget Settings configuration, *and* Membership management (add/remove/update roles).
*   **`InvitationService`**: Highly cohesive. Handles the specific lifecycle of invitation tokens and email dispatch.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Performance / Redundant I/O]** - `src/projects/project.service.ts`:
    *   **Violation**: `validateProjectMembership` is called in almost every service method (`update`, `findOne`, `getProjectMembers`). Since the `ProjectController` is already guarded by `RolesGuard` (which checks membership), this causes a **Double Database Hit** for the same permission check on every request.
    *   **Strategy**: Trust the `RolesGuard` for permission enforcement. Refactor service methods to accept the `Project` entity (passed from the Guard via request context) or `projectId` without re-verifying membership, or implement a Request-Scoped Cache (e.g., `NestJS ContextIdFactory`) to share the membership record between Guard and Service.

2.  **[Low Cohesion / SRP Violation]** - `src/projects/project.service.ts`:
    *   **Violation**: `ProjectService` handles both Project entity management (`create`, `update`, `widgetSettings`) and Member management (`getProjectMembers`, `updateMemberRole`, `removeMember`).
    *   **Strategy**: Extract member-related logic into a dedicated `ProjectMembersService`. This separates the concerns of "Tenant Configuration" from "Tenant Access Management".

3.  **[Boilerplate / Maintenance Risk]** - `src/projects/project.service.ts`:
    *   **Violation**: `findAllForUser` performs manual object mapping (`members.map(...)`) to transform entities into the response shape. This couples the service logic to the specific response format and is prone to drift.
    *   **Strategy**: Use a dedicated **Assembler/Mapper** class or a library like `automapper` (or simply a constructor in the DTO) to handle Entity-to-DTO transformation centrally.

4.  **[DRY Violation]** - `src/projects/invitation.service.ts`:
    *   **Violation**: Expiry logic (`new Date() > invitation.expiresAt`) and status checks (`status !== PENDING`) are duplicated in `acceptInvitation` and `getInvitationByToken`.
    *   **Strategy**: Encapsulate invitation validity logic into a method on the `Invitation` entity itself (e.g., `invitation.isValid()`) or a private helper method in the service.

5.  **[Logging Noise]** - `src/projects/invitation.service.ts`:
    *   **Violation**: `acceptInvitation` contains excessive logging (`Starting acceptance process`, `Found invitation`, `Found user`, `Email match verified`). This pollutes production logs with high-volume operational noise.
    *   **Strategy**: Reduce log levels to `debug` for flow tracing. Keep `log` or `warn` only for significant state changes (Success/Failure).

6.  **[Brittle Logic]** - `src/projects/project.service.ts`:
    *   **Violation**: `getWidgetSettings` relies on `new URL(origin)`. If the `Origin` header is malformed (but not empty), this throws a generic error.
    *   **Strategy**: Wrap the URL parsing in a specific `try-catch` block that throws a `BadRequestException` ("Invalid Origin Format") rather than letting the generic error bubble up, providing clearer feedback to the client/integrator.

---

### Batch: Batch 9: Inbox and Conversation Management
**Intent**: Analyze the core inbox functionality, including conversation and message management, assignment logic, event handling, and persistence services. This reveals the central communication flow of the application.

**Files Analyzed**:
- `src/inbox/inbox.module.ts`
- `src/inbox/inbox.controller.ts`
- `src/inbox/assignments.controller.ts`
- `src/inbox/dto/assign-conversation.dto.ts`
- `src/inbox/events.ts`
- `src/inbox/inbox-event.handler.ts`
- `src/inbox/inbox.persistence.module.ts`
- `src/inbox/services/conversation.service.ts`
- `src/inbox/services/message.service.ts`
- `src/inbox/services/persistence/conversation.persistence.service.ts`
- `src/inbox/services/persistence/message.persistence.service.ts`
- `src/inbox/services/persistence/visitor.persistence.service.ts`
- `src/inbox/services/visitor.service.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Communication Topology & Data Flow**
The Inbox module orchestrates a **Bi-Directional, Asynchronous Communication Architecture**.
*   **Visitor Ingress (Event-Driven)**:
    *   **Path**: Gateway $\rightarrow$ `InboxEventHandlerService` $\rightarrow$ BullMQ (`live-chat-events-queue`).
    *   **Pattern**: **Async Ingestion**. Visitor messages are not immediately persisted by the receiving node. They are buffered into a queue to decouple high-volume socket traffic from database write throughput.
    *   **Lazy Instantiation**: `InboxEventHandlerService` employs a **Lazy Load** strategy for conversations. It resolves the `Visitor` immediately but defers `Conversation` creation until the first message is processed (handled in the persistence layer), optimizing storage for "window shoppers."
*   **Agent Ingress (Synchronous API)**:
    *   **Path**: `InboxController` $\rightarrow$ `MessageService` $\rightarrow$ Database Transaction $\rightarrow$ Gateway.
    *   **Pattern**: **Write-Through**. Agent replies are persisted immediately within a transaction to ensure consistency before being broadcast.
*   **Realtime Propagation (Outbox Loop)**:
    *   **Mechanism**: The `InboxEventHandlerService` subscribes to `redis.message.received`. This completes the **Transactional Outbox** loop established in previous batches: DB Write $\rightarrow$ Outbox $\rightarrow$ Redis Pub/Sub $\rightarrow$ `InboxEventHandlerService` $\rightarrow$ Gateway $\rightarrow$ Client. This ensures that clients only receive messages that are durably committed.

**2. State Management & Persistence**
*   **Persistence Isolation**: The module introduces `InboxPersistenceModule`, explicitly separating **Business Logic** (`ConversationService`) from **Data Access** (`ConversationPersistenceService`). This is a partial implementation of the **Repository Pattern**, though `ConversationService` still leaks `EntityManager` usage in methods like `assign` and `listByProject`.
*   **Hybrid State Hydration**:
    *   `ConversationService.listByProject` implements a **Split-State Aggregation**. It fetches persistent data (Conversations/Visitors) from Postgres and hydrates ephemeral state (`currentUrl`) from Redis using a bulk `MGET` strategy. This avoids N+1 queries and keeps high-churn presence data out of the relational store.
*   **History Visibility**: `ConversationPersistenceService` implements domain-specific query logic for `HistoryVisibilityMode` (`forever` vs `limit_to_active`), enforcing tenant-level configuration at the query builder level.

**3. Coupling & Cohesion**
*   **The "God Service" Risk**: `ConversationService` exhibits **High Coupling**. It depends on `EntityManager`, `RealtimeSessionService`, `EventsGateway` (Circular), `ProjectService`, and `ConversationPersistenceService`. It manages lifecycle, assignment, search, and realtime notification orchestration.
*   **Workflow Coupling**: `MessageService` directly injects `workflowQueue` to schedule `auto-pending` jobs. This creates a **Hard Dependency** between the core messaging domain and the auxiliary workflow engine.
*   **Circular Dependency**: `InboxModule` and `GatewayModule` use `forwardRef`. The Gateway depends on Inbox services to resolve entities, while Inbox services depend on the Gateway to emit events.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Inconsistent Abstraction]** - `src/inbox/services/conversation.service.ts`:
    *   **Violation**: The service mixes usage of `ConversationPersistenceService` (for `findOrCreate`) with direct `EntityManager` usage (for `assign`, `unassign`, `updateStatus`, `listByProject`).
    *   **Strategy**: Move all direct database queries (QueryBuilders, `findOne`, `save`) into `ConversationPersistenceService`. `ConversationService` should strictly orchestrate business logic and delegate data access.

2.  **[Type Safety / Validation]** - `src/inbox/inbox-event.handler.ts`:
    *   **Violation**: `isValidRedisMessagePayload` is a manual, verbose type guard function (~40 lines). It is brittle and duplicates schema definitions found elsewhere.
    *   **Strategy**: Replace with a runtime validation library like `zod` or `class-validator` (using `plainToInstance` and `validateSync`) to enforce the schema of Redis payloads robustly and concisely.

3.  **[SRP Violation / Long Method]** - `src/inbox/services/message.service.ts`:
    *   **Violation**: `sendAgentReply` handles: DB transaction, permission checks, message creation, conversation update, Redis session lookup, Gateway emission, and Workflow queue scheduling.
    *   **Strategy**: Decompose.
        1.  Extract workflow scheduling to a `WorkflowTriggerService`.
        2.  Extract notification logic to a `NotificationService`.
        3.  Keep `MessageService` focused on the transactional persistence of the reply.

4.  **[API Design / Complexity]** - `src/inbox/inbox.controller.ts`:
    *   **Violation**: `updateConversation` handles two distinct business actions (`status` change vs `read` marking) in a single endpoint based on payload shape.
    *   **Strategy**: Split into explicit endpoints: `PATCH conversations/:id/status` and `POST conversations/:id/read`. This simplifies the controller logic, DTOs, and RBAC policies (e.g., maybe only Agents can read, but Managers can close).

5.  **[Magic Strings]** - `src/inbox/inbox-event.handler.ts`:
    *   **Violation**: Hardcoded event strings `'visitor.identified'`, `'visitor.message.received'`, `'redis.message.received'`.
    *   **Strategy**: Centralize these into a `SystemEvents` enum or constant object (shared with the Event Emitter configuration) to prevent contract drift between producers and consumers.

6.  **[Implicit Logic]** - `src/inbox/inbox-event.handler.ts`:
    *   **Violation**: The `historyMode` defaults to `'limit_to_active'` if `project?.widgetSettings` is missing. This default logic is buried in the event handler.
    *   **Strategy**: Move this default into the `Project` entity (via `@AfterLoad` or a getter) or the `ConversationPersistenceService`. The event handler should not be responsible for interpreting configuration defaults.

---

### Batch: Batch 10: Visitor and Visitor Notes Management
**Intent**: Examine the modules responsible for managing visitors and their associated notes. This provides insight into how external users are tracked and internal annotations are managed within the system.

**Files Analyzed**:
- `src/visitors/visitors.module.ts`
- `src/visitors/visitors.controller.ts`
- `src/visitors/visitors.service.ts`
- `src/visitors/dto/update-visitor.dto.ts`
- `src/visitors/dto/visitor-response.dto.ts`
- `src/visitor-notes/visitor-notes.module.ts`
- `src/visitor-notes/visitor-notes.controller.ts`
- `src/visitor-notes/visitor-notes.service.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Visitor State Topology (Hybrid Aggregation)**
The Visitor module implements a **Split-State Aggregation Pattern**, merging persistent relational data with ephemeral realtime status.
*   **Persistent State (Postgres)**: The `Visitor` entity stores stable identity (`visitorUid`, `displayName`) and historical metadata (`lastSeenAt`, `createdAt`).
*   **Ephemeral State (Redis)**: The `isOnline` status is not stored in the database but is hydrated at runtime via `RealtimeSessionService.isVisitorOnline`.
*   **Aggregation Layer**: `VisitorsService.findOne` acts as the assembler, fetching the entity from TypeORM and the presence boolean from Redis, then mapping them to a `SharedVisitorType`. This ensures the API consumer receives a holistic view of the visitor without the database needing to track high-churn socket connections.

**2. Annotation Subsystem (Visitor Notes)**
*   **Relational Model**: `VisitorNote` implements a standard child entity relationship. It links a `Visitor` (Subject) and a `User` (Author).
*   **Implicit Authorization**: `VisitorNotesService.findAll` and `findOne` enforce tenancy via relation filtering (`where: { visitor: { projectId } }`). This ensures that agents cannot access notes for visitors in projects they do not belong to, leveraging the existing `Visitor` $\rightarrow$ `Project` link.
*   **Realtime Feedback**: CRUD operations on notes trigger immediate WebSocket events (`VISITOR_NOTE_ADDED`, etc.) via `EventsGateway`, allowing agent interfaces to update live without polling.

**3. Event Propagation & Coupling**
*   **Circular Dependency**: `VisitorsModule` and `GatewayModule` utilize `forwardRef`. The Gateway needs `VisitorsService` to resolve visitor entities from socket payloads, while `VisitorsService` needs `EventsGateway` to broadcast updates. This indicates a tight coupling between the Domain Layer and the Transport Layer.
*   **Inconsistent Abstraction**:
    *   `VisitorNotesService` uses the encapsulated `eventsGateway.emitToProject` method.
    *   `VisitorsService` breaks encapsulation by accessing the raw socket server: `this.eventsGateway.server.to(...)`. This leaks implementation details (Socket.IO rooms) into the domain service.

**4. Type Safety & Data Integrity**
*   **Entity/DTO Mismatch**: `VisitorsService.findOne` employs aggressive type casting (`as any`) to map properties like `email`, `phone`, and `customData`. This suggests that the `Visitor` entity definition in the codebase is out of sync with the `SharedVisitorType` interface or the actual database schema, creating a **Runtime Safety Gap**.
*   **Redundant Validation**: `VisitorsService.updateDisplayName` manually validates string length and emptiness. Since `UpdateVisitorDto` is decorated with `class-validator` (`@Length`, `@IsString`), and the controller uses `ValidationPipe` (implied globally or standard NestJS behavior), this service-level validation is dead code that violates DRY.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Type Safety / Technical Debt]** - `src/visitors/visitors.service.ts`:
    *   **Violation**: Usage of `(visitorEntity as any).email` and `(visitorEntity as any).customData`. This bypasses the type system, masking potential bugs if the Entity definition does not actually have these fields.
    *   **Strategy**: Update the `Visitor` entity definition to explicitly include `email`, `phone`, `customData`, etc., matching the database schema. Remove the `as any` cast.

2.  **[Leaky Abstraction]** - `src/visitors/visitors.service.ts`:
    *   **Violation**: Direct access to `this.eventsGateway.server.to(...)`. This couples the service to the specific WebSocket implementation (Socket.IO) and its room naming convention.
    *   **Strategy**: Refactor `EventsGateway` to expose a typed method `emitVisitorUpdate(projectId, visitor)` and call that method from the service.

3.  **[DRY Violation / Dead Code]** - `src/visitors/visitors.service.ts`:
    *   **Violation**: Manual validation checks (`if (!displayName)`, `if (displayName.length > 50)`) inside `updateDisplayName`. These rules are already defined in `UpdateVisitorDto`.
    *   **Strategy**: Remove manual checks. Rely on the global `ValidationPipe` to enforce DTO constraints before the request reaches the service.

4.  **[Magic Strings]** - `src/visitors/visitors.service.ts`:
    *   **Violation**: Hardcoded room string construction `` `project.${projectId}` ``.
    *   **Strategy**: Centralize room naming logic. Use a static helper like `RoomUtils.getProjectRoom(projectId)` or a constant in `EventsGateway` to ensure consistency across the application.

5.  **[Architectural Cycle]** - `src/visitors/visitors.module.ts`:
    *   **Violation**: `forwardRef(() => GatewayModule)`.
    *   **Strategy**: Decouple using an Event Bus (e.g., `EventEmitter2`). `VisitorsService` should emit a local domain event (`VisitorUpdatedEvent`), and a separate `GatewayEventListener` (in the Gateway module) should listen to it and broadcast via WebSockets. This inverts the dependency.

---

### Batch: Batch 11: Webhook Management and Dispatch
**Intent**: Analyze the webhook module, covering subscription management, controller logic, service implementation, and the dispatch/processing mechanisms. This reveals how the system integrates with external services through event notifications.

**Files Analyzed**:
- `src/webhooks/webhooks.module.ts`
- `src/webhooks/webhooks.controller.ts`
- `src/webhooks/webhooks.service.ts`
- `src/webhooks/dto/create-subscription.dto.ts`
- `src/webhooks/webhook.dispatcher.ts`
- `src/webhooks/webhook.processor.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Webhook Subsystem Topology**
The Webhook module implements a **Reliable Push Architecture** designed to bridge the internal event bus with external subscriber endpoints.
*   **Ingestion Layer (Dispatcher)**: `WebhookDispatcher` acts as a bridge between the ephemeral Redis Pub/Sub (`NEW_MESSAGE_CHANNEL`) and the durable BullMQ (`WEBHOOKS_QUEUE`). It filters events based on project subscriptions before they enter the job queue, reducing noise.
*   **Execution Layer (Processor)**: `WebhookProcessor` consumes jobs, executing HTTP POST requests. It implements **At-Least-Once Delivery** with exponential backoff retries (via BullMQ configuration).
*   **Audit Layer (Delivery Log)**: Every attempt is recorded in `WebhookDelivery` with a status lifecycle (`PENDING` $\rightarrow$ `SUCCESS` / `FAILURE`). This provides a granular audit trail for debugging integration issues.

**2. Security & Integrity Mechanisms**
*   **SSRF Defense (Server-Side Request Forgery)**: `WebhooksService.validateUrl` implements a **Defense-in-Depth** strategy against SSRF.
    *   **DNS Resolution**: It resolves the hostname to all associated IP addresses.
    *   **IP Filtering**: It explicitly blocks private ranges (`loopback`, `private`, `uniqueLocal`, `carrierGradeNat`) using `ipaddr.js`. This prevents attackers from using the webhook engine to scan internal infrastructure (e.g., AWS Metadata service, local Redis).
*   **Payload Integrity**: `WebhookProcessor` signs payloads using **HMAC-SHA256** (`X-Hub-Signature-256`). This allows receivers to verify that the request originated from the system and was not tampered with.
*   **Environment Isolation**: Both the DTO validator and the Service logic contain explicit checks for `NODE_ENV === 'test'` to allow `localhost` URLs during testing, while enforcing HTTPS and blocking loopback in production.

**3. Data Flow & Coupling**
*   **Event Mapping**: The `WebhookDispatcher` currently hardcodes the event trigger to `'message.created'` when receiving data from `NEW_MESSAGE_CHANNEL`. This implies a **Rigid Coupling** to a single event type, limiting the system's ability to support other triggers (e.g., `conversation.started`) without code modification.
*   **In-Memory Filtering**: `WebhooksService.findActiveByProjectAndTrigger` fetches *all* active subscriptions for a project and filters the `eventTriggers` array in JavaScript. While functional, this moves query logic out of the database, potentially causing performance degradation if a project has hundreds of subscriptions.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Performance / Scalability]** - `src/webhooks/webhooks.service.ts`:
    *   **Violation**: `findActiveByProjectAndTrigger` fetches all active subscriptions and filters `eventTriggers` (likely a JSON array or string array) in memory.
    *   **Strategy**: Push the filtering to the database layer. Use a Postgres array operator (e.g., `ANY` or `@>`) or JSONB containment query to fetch only the subscriptions relevant to the specific trigger.

2.  **[Hardcoded Logic / Extensibility]** - `src/webhooks/webhook.dispatcher.ts`:
    *   **Violation**: The dispatcher hardcodes the event name: `await this.processEvent(projectId, 'message.created', payload)`. It assumes all traffic on `NEW_MESSAGE_CHANNEL` maps to `message.created`.
    *   **Strategy**: The Redis payload should include the `eventType` (e.g., `{ type: 'message.created', payload: ... }`). The dispatcher should extract this type dynamically to support multiple event triggers without code changes.

3.  **[Configuration / Resilience]** - `src/webhooks/webhook.processor.ts`:
    *   **Violation**: Hardcoded `timeout: 5000` in the Axios request.
    *   **Strategy**: Move the timeout value to `ConfigService` or a constant. 5 seconds might be too aggressive for some slow-consuming endpoints, or too lenient for high-throughput systems.

4.  **[Type Safety / Correctness]** - `src/webhooks/webhook.processor.ts`:
    *   **Violation**: `eventId: typeof eventId === 'number' ? eventId.toString() : eventId`. This manual type checking suggests inconsistent payload shapes upstream.
    *   **Strategy**: Standardize the event payload interface (e.g., `IWebhookEventPayload`) across the Producer and Consumer to ensure `id` is always a string (UUID) or always a number, removing runtime type guessing.

5.  **[Error Handling / Observability]** - `src/webhooks/webhook.processor.ts`:
    *   **Violation**: The processor catches errors, saves the delivery as `FAILURE`, and then *rethrows* the error.
    *   **Strategy**: This is actually a correct pattern for BullMQ (rethrow triggers retry), but the logging could be improved. Ensure that the `FAILURE` status is only final after the max retries are exhausted (using `OnWorkerEvent('failed')`), otherwise the logs will show multiple "FAILURES" for a single eventual success. Currently, it logs a failure record for *every* retry attempt, which is verbose but acceptable if intended.

---

### Batch: Batch 12: Auxiliary Features (Mail, Canned Responses, Screenshot, Workflow)
**Intent**: Examine the remaining auxiliary features, including email services, canned responses, screenshot capture, and workflow automation. This completes the understanding of the system's various functionalities.

**Files Analyzed**:
- `src/mail/mail.module.ts`
- `src/mail/mail.controller.ts`
- `src/mail/mail.service.ts`
- `src/mail/email-template.service.ts`
- `src/canned-responses/canned-responses.module.ts`
- `src/canned-responses/canned-responses.controller.ts`
- `src/canned-responses/canned-responses.service.ts`
- `src/screenshot/screenshot.module.ts`
- `src/screenshot/screenshot.controller.ts`
- `src/screenshot/screenshot.service.ts`
- `src/modules/workflow/workflow.module.ts`
- `src/modules/workflow/workflow.consumer.ts`

**Insight**:
### Core Data Structures & Architectural Analysis

**1. Auxiliary Subsystems Topology**
The system integrates four distinct auxiliary domains, ranging from simple CRUD to complex resource-intensive operations.
*   **Canned Responses (CRUD)**: Standard layered architecture (`Controller` $\rightarrow$ `Service` $\rightarrow$ `Repository`). Enforces tenancy via `projectId` in all queries.
*   **Mail Subsystem (Notification)**:
    *   **Transport**: Wraps `nodemailer` for SMTP delivery.
    *   **Templating**: `EmailTemplateService` generates HTML strings directly in code. It supports basic localization (Vietnamese/English) via conditional logic, creating a **Hardcoded Presentation Layer**.
*   **Workflow Automation (Background Processing)**:
    *   **Consumer**: `WorkflowConsumer` processes `conversation-workflow-queue` jobs (specifically `auto_pending`).
    *   **Atomicity**: Implements **Optimistic Concurrency Control** via SQL `UPDATE ... WHERE status = OPEN AND last_message_id = triggerId`. This ensures that if a user replies (changing `last_message_id`) or the status changes while the job was in the queue, the automation correctly fails/skips.
*   **Screenshot Engine (Utility)**:
    *   **Headless Browser**: Wraps `puppeteer` in a Singleton service.
    *   **Resource Governance**: Implements a **Semaphore Pattern** (`activePages` counter) to limit concurrent browser contexts (Max 5), preventing memory exhaustion.
    *   **Caching**: Uses Redis to cache binary image data (base64 encoded) for 60 seconds, reducing CPU load on frequent requests.

**2. Security & Defense Mechanisms**
*   **SSRF Defense (Screenshot)**:
    *   **Layered Validation**: The `ScreenshotController` implements a rigorous **Server-Side Request Forgery (SSRF)** defense.
    *   **Blocklists**: Explicitly blocks metadata services (AWS/GCP/Azure) and localhost.
    *   **DNS Resolution**: Resolves hostnames to IPs to detect private network access (e.g., `127.0.0.1`, `10.x.x.x`) using `ipaddr.js`.
    *   **Placement Flaw**: This critical security logic resides entirely in the **Controller**, leaving the Service vulnerable if invoked internally or via a new entry point.
*   **Access Control**:
    *   **Mail**: `MailController` exposes a `test-send` endpoint protected by `GlobalRole.ADMIN`. While guarded, shipping test tools in production code increases the attack surface.
    *   **Canned Responses**: Granular RBAC (`MANAGER` can Write, `AGENT` can Read).

**3. Coupling & Cohesion**
*   **Presentation Coupling**: `EmailTemplateService` mixes business logic (URL generation) with presentation (HTML strings). This violates Separation of Concerns and makes email redesigns require code deployments.
*   **Infrastructure Leakage**: `CannedResponsesService` catches Postgres error code `'23505'` (Unique Violation) directly. This couples the service layer to the specific SQL dialect.
*   **Event Coupling**: `WorkflowConsumer` injects `EventsGateway` to emit socket events. It manually constructs the room string `project:${projectId}` and event name `'automation.triggered'`, duplicating logic found in the Gateway and other consumers.

---

### [LOG: REFACTORING CANDIDATES]

1.  **[Separation of Concerns / Maintainability]** - `src/mail/email-template.service.ts`:
    *   **Violation**: HTML templates are hardcoded as template literals within the service class. This makes the file huge, hard to read, and difficult to edit by non-developers.
    *   **Strategy**: Extract templates to external files (e.g., `.hbs`, `.ejs`) and use a template engine (like `handlebars` or `@nestjs-modules/mailer`). This separates Presentation from Logic.

2.  **[Security / Architectural Layering]** - `src/screenshot/screenshot.controller.ts`:
    *   **Violation**: Critical SSRF protection logic (DNS resolution, IP blocking) is implemented in the Controller. If `ScreenshotService.getScreenshot` is injected and called by another internal service (e.g., a bot preview feature), it bypasses these checks.
    *   **Strategy**: Move the URL validation and SSRF protection logic into a `UrlSecurityService` or directly into the `ScreenshotService` as a `validateSafeUrl` method. The Service should be secure by default.

3.  **[Leaky Abstraction]** - `src/canned-responses/canned-responses.service.ts`:
    *   **Violation**: Explicit check for `error.code === '23505'`. This ties the service to the PostgreSQL driver.
    *   **Strategy**: Implement a global `TypeOrmExceptionFilter` or wrap the repository call to translate DB-specific errors into domain exceptions (`DuplicateResourceException`).

4.  **[Magic Strings / Contract Drift]** - `src/modules/workflow/workflow.consumer.ts`:
    *   **Violation**: Hardcoded socket event name `'automation.triggered'` and room pattern `` `project:${projectId}` ``.
    *   **Strategy**: Use shared constants or a typed Event Factory (e.g., `SocketEvents.automationTriggered(payload)`) to ensure the backend emitter and frontend listener stay in sync.

5.  **[Operational Risk]** - `src/mail/mail.controller.ts`:
    *   **Violation**: `sendTestEmail` endpoint exists in the production codebase. Even with `ADMIN` guard, it allows an attacker with compromised admin credentials to use the server as a spam relay.
    *   **Strategy**: Remove this controller entirely in production builds, or wrap it in a `if (process.env.NODE_ENV === 'development')` conditional module import.

6.  **[Race Condition / Security]** - `src/screenshot/screenshot.controller.ts`:
    *   **Violation**: **Time-of-Check to Time-of-Use (TOCTOU)**. The controller resolves the DNS to check the IP, but then passes the *hostname* (URL) to Puppeteer. Puppeteer performs a *second* DNS resolution. If an attacker controls the DNS server, they can return a safe IP for the first check and a private IP (127.0.0.1) for the second (DNS Rebinding Attack).
    *   **Strategy**: While difficult to solve perfectly with Puppeteer, a mitigation is to configure the browser to use a proxy that enforces the allowlist, or (more complex) resolve the IP and force Puppeteer to navigate to the IP address while setting the `Host` header to the original hostname (though this breaks SNI for HTTPS). At minimum, acknowledge the risk or use a dedicated egress proxy.

---

## High-Level Summary

# High-Density Architectural Digest: Project Knowledge Graph

### [SYSTEM TOPOLOGY & INFRASTRUCTURE]

**Architecture Style**: Monolithic Modular with Event-Driven Extensions.
**Tenancy Model**: Strict Project-Based Multi-tenancy (`projectId` FK enforcement).
**State Distribution**:
*   **Primary Store**: PostgreSQL (Relational Data, JSONB Documents).
*   **Ephemeral/Hot Store**: Redis (Session Cache, Presence, Pub/Sub, Rate Limiting).
*   **Async Transport**: BullMQ (Job Queues) + Redis Pub/Sub (Realtime Broadcast).

**Global Patterns**:
*   **Transactional Outbox**: Decouples DB writes from Event Bus. Events persist to `outbox_events` within the business transaction, then propagate asynchronously.
*   **Split-State Aggregation**: Entities like `Visitor` and `Conversation` hydrate persistent data from Postgres and volatile status (Online/Typing) from Redis at runtime.
*   **Aspect-Oriented Auditing**: `@Auditable` decorator + Interceptors for compliance logging, decoupled from business logic.

---

### [DATA ARCHITECTURE & PERSISTENCE]

**1. Hybrid Identity Strategy**
*   **Security Domain (UUID)**: `User`, `RefreshToken`, `Invitation`, `AuditLog`. Prevents enumeration.
*   **Operational Domain (BigInt/Int)**: `Conversation`, `Message`. Optimized for indexing/storage.
*   **Dual-ID Entities**: `Visitor` uses `id` (Int) for internal joins and `visitorUid` (UUID) for public API exposure.

**2. Schema Characteristics**
*   **Polymorphism**: `AuditLog` and `OutboxEvent` use generic `entityId` (String) to reference mixed ID types.
*   **JSONB Extensibility**: Heavy usage in `Project.widgetSettings`, `Message.attachments`, and `Conversation.metadata` to avoid DDL churn.
*   **Configuration Drift**: Dual-config setup (`database.config.ts` vs `data-source.ts`) creates risk of missing entities in CLI migrations.

**3. Concurrency & Locking**
*   **Pessimistic Locking**: `OutboxPersistenceService` uses raw SQL `FOR UPDATE SKIP LOCKED` to allow concurrent event dispatchers.
*   **Optimistic Locking**: Workflow automation uses state-based predicates (`WHERE status = OPEN AND last_message_id = ...`) to prevent race conditions.

---

### [SECURITY & AUTHENTICATION]

**1. Authentication Flow**
*   **Hybrid Token System**: Stateless Access Tokens (JWT) + Stateful Refresh Tokens (DB-backed, Rotational).
*   **Partial Authority Pattern**: 2FA flows issue a restricted `2fa_partial_token` (Cookie) granting access *only* to verification endpoints before upgrading to full session.
*   **Session Governance**: Strict `SESSION_LIMIT` (LRU eviction) and global revocation via `tokensValidFrom` timestamp.

**2. Cryptography**
*   **Algorithm**: AES-256-GCM for sensitive fields.
*   **Key Management**: Raw string buffering (Risk: Byte length validation flaw).
*   **Hashing**: Bcrypt for passwords and refresh tokens. **Performance Risk**: Linear scan + `bcrypt.compare` used in `verifyRefreshToken` and `UserSecurityService` creates DoS vectors.

**3. Access Control (RBAC/OBAC)**
*   **Hierarchical RBAC**: Hardcoded roles (`Admin > User`).
*   **Context-Aware Guards**: `RolesGuard` binds to `params.projectId`. **Coupling**: Guard injects `EntityManager` directly.
*   **Origin-Based Access (OBAC)**: `ProjectService` enforces CORS-like whitelisting at the application layer using `Origin` headers.

---

### [EVENT BUS & ASYNC PIPELINE]

**1. Ingestion & Processing**
*   **Visitor Ingress**: Async. Gateway $\rightarrow$ BullMQ (`live-chat-events-queue`) $\rightarrow$ DB. Lazy conversation creation.
*   **Agent Ingress**: Sync. API $\rightarrow$ DB Transaction $\rightarrow$ Outbox.
*   **Propagation**: `OutboxListenerService` (Postgres `LISTEN` + Polling) $\rightarrow$ Redis Pub/Sub $\rightarrow$ Gateway/Webhooks.

**2. Webhook Subsystem**
*   **Architecture**: Dispatcher (Redis Filter) $\rightarrow$ Queue $\rightarrow$ Processor (HTTP).
*   **Security**: HMAC-SHA256 signing (`X-Hub-Signature-256`).
*   **SSRF Defense**: DNS resolution + IP filtering (blocks private ranges) via `ipaddr.js`.

---

### [CORE DOMAIN MODULES]

**1. Realtime Gateway (`EventsGateway`)**
*   **Role**: Stateful WebSocket Gateway (Socket.IO + Redis Adapter).
*   **Architecture**: **God Class**. Injects 11 services. Handles Auth, Routing, and DB mutations (`handleUpdateContext`).
*   **Coupling**: Circular dependencies with `InboxModule` and `VisitorsModule` (solved via `forwardRef`).

**2. Inbox & Conversation**
*   **Persistence**: Partial Repository Pattern (`ConversationPersistenceService`).
*   **Logic**: `MessageService` is highly coupled to Workflow and Notification subsystems.
*   **State**: `ConversationService.listByProject` performs bulk `MGET` from Redis to merge presence data with DB results.

**3. Visitor Management**
*   **Aggregation**: `VisitorsService` assembles `SharedVisitorType` from DB Entity + Redis Session.
*   **Safety Gap**: Extensive use of `as any` casting in service layer masks schema mismatches.

**4. Auxiliary Services**
*   **Screenshot**: Puppeteer-based. **Critical Risk**: TOCTOU DNS Rebinding vulnerability in Controller-based SSRF check.
*   **Mail**: Hardcoded HTML templates within Service classes.
*   **Project**: `ProjectService` acts as a God Service for Tenant + Member management.

---

### [RISK REGISTRY & TECHNICAL DEBT]

**High Severity (Security & Stability)**
*   **[CRITICAL] SSRF/TOCTOU**: `ScreenshotController` validates URL IP, then Puppeteer resolves it again. Vulnerable to DNS Rebinding.
*   **[HIGH] DoS Vector**: `TokenService` and `UserSecurityService` perform linear scans with `bcrypt.compare` (CPU intensive) on collections.
*   **[HIGH] Process Management**: `main.ts` uses `execSync('kill -9')` based on `lsof`. Dangerous in production/containers.
*   **[HIGH] Crypto Validation**: `EncryptionService` checks `key.length !== 32` (character count) instead of Byte length.

**Medium Severity (Architecture & Coupling)**
*   **[ARCH] Circular Dependencies**: Gateway $\leftrightarrow$ Domain Modules rely on `forwardRef`. Needs Event Bus decoupling.
*   **[ARCH] God Classes**: `EventsGateway`, `ProjectService`, `AuthController` violate SRP with massive dependency lists.
*   **[ARCH] Leaky Abstractions**: Services relying on raw SQL (`OutboxPersistence`), specific DB error codes (`CannedResponses`), or Socket.IO internals (`server.to()`).
*   **[ARCH] Config Drift**: `data-source.ts` (CLI) manually lists entities, risking desync from `database.config.ts` (Runtime).

**Low Severity (Code Quality)**
*   **[CODE] Type Safety**: Manual `as any` casting in `VisitorsService`.
*   **[CODE] Magic Strings**: Hardcoded event names (`'message.created'`), Redis channels, and Room IDs scattered across modules.
*   **[CODE] Dead Code**: `LoggingInterceptor` exists but `LoggerMiddleware` is used.
*   **[CODE] Hardcoded Logic**: Email templates in code; Webhook event triggers hardcoded in Dispatcher.

