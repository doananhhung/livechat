# Codebase Context: Architectural Intelligence

> Generated by Gemini Agent at 12/10/2025, 3:33:14 PM

## Research Strategy
The batching strategy prioritizes understanding the system's 'Load-Bearing Structures' by traversing its dependency graph from foundational data structures to core services, then to vertical feature slices, and finally to supporting infrastructure. Following 'Torvalds' Law', we begin with data structures (database entities, common types) as the bedrock. Subsequent batches build upon this foundation, introducing core application setup, authentication, eventing, and specific features. 'Gall's Law' is applied by starting with primitive core files (entities, main app setup) before moving to more complex, interconnected features. 'The Vertical Slice' heuristic is used to group related components (controllers, services, modules, strategies, guards) for key features like authentication and inbox, ensuring a holistic understanding of their coupling. Each batch adheres to the 30-file limit, focusing on 'Physics' (logic and state) over 'Paint' (UI/assets).

## Architectural Insights

### Batch: Batch 1: Core Data Structures (Database Entities & Common Types)
**Intent**: Establish the fundamental data model of the application by ingesting all database entity definitions and common interfaces. This provides the 'what' of the system's state, crucial for understanding any logic that operates on it.

**Files Analyzed**:
- `backend/src/common/types/authenticated-request.interface.ts`
- `backend/src/common/types/two-factor-request.interface.ts`
- `backend/src/database/data-source.ts`
- `backend/src/database/entities/conversation.entity.ts`
- `backend/src/database/entities/email-change-request.entity.ts`
- `backend/src/database/entities/index.ts`
- `backend/src/database/entities/invitation.entity.ts`
- `backend/src/database/entities/message.entity.ts`
- `backend/src/database/entities/outbox-event.entity.ts`
- `backend/src/database/entities/project-member.entity.ts`
- `backend/src/database/entities/project.entity.ts`
- `backend/src/database/entities/refresh-token.entity.ts`
- `backend/src/database/entities/two-factor-recovery-code.entity.ts`
- `backend/src/database/entities/user-identity.entity.ts`
- `backend/src/database/entities/user.entity.ts`
- `backend/src/database/entities/visitor.entity.ts`
- `backend/src/database/migrations/1765354370752-InitialSchema.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & DATA MODEL**
*   **Persistence Layer**: PostgreSQL (via TypeORM).
*   **ORM Strategy**: Active Record / Data Mapper hybrid (Entities defined with decorators).
*   **Naming Strategy**: `SnakeNamingStrategy` enforced globally.
*   **ID Strategy**: Mixed.
    *   `UUID`: User, RefreshToken, UserIdentity, Invitation, EmailChangeRequest, OutboxEvent.
    *   `BigInt/Increment`: Conversation, Message, TwoFactorRecoveryCode.
    *   `Int/Increment`: Project, ProjectMember, Visitor.

**2. ENTITY RELATIONSHIP GRAPH (Directed)**
*   **User (Root Aggregate)**
    *   `1:N` -> `RefreshToken` (Cascade: DELETE)
    *   `1:N` -> `UserIdentity` (Cascade: DELETE)
    *   `1:N` -> `TwoFactorRecoveryCode` (Cascade: DELETE)
    *   `1:N` -> `ProjectMember` (Cascade: None defined on User side, Cascade DELETE on Member side)
    *   `1:N` -> `EmailChangeRequest` (Cascade: DELETE)
*   **Project (Root Aggregate)**
    *   `1:N` -> `ProjectMember` (Cascade: DELETE)
    *   `1:N` -> `Conversation` (Cascade: DELETE)
    *   `1:N` -> `Visitor` (Cascade: DELETE)
*   **Conversation**
    *   `N:1` -> `Project`
    *   `N:1` -> `Visitor`
    *   `1:N` -> `Message` (Cascade: DELETE)
*   **Visitor**
    *   `N:1` -> `Project`
    *   `1:N` -> `Conversation`
    *   **Hybrid State**: `currentUrl` is runtime-only (Redis implied), not persisted in SQL.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Global State**: `AppDataSource` (Singleton). Initialized with `dotenv` and `ConfigService`.
    *   **Entity State**: Mutable. Managed by TypeORM `Repository` pattern.
    *   **Request State**: `AuthenticatedRequest` and `TwoFactorRequest` extend Express `Request` to carry ephemeral auth context (`user.sub`, `user.id`).

*   **Mutation Risk**:
    *   **Cascade Propagation**: High risk. Deleting a `Project` triggers a massive cascade deleting `Conversations`, `Messages`, `Visitors`, and `ProjectMembers`.
    *   **Type Mismatch**: `Message.id` typed as `number | string` but defined as `bigint` (SQL `BIGSERIAL`). JS `number` cannot safely hold large `bigint` values (precision loss > 2^53).
    *   **Schema Drift**: `OutboxEvent` uses `snake_case` property names (`aggregate_type`) directly in the class, violating the camelCase convention used in all other entities (e.g., `User.fullName`).

*   **Coupling & Cohesion**:
    *   **User Entity**: Low Cohesion. Acts as a "God Class" holding Auth (password, 2FA), Profile (avatar, lang), and Domain Relations (projects).
    *   **ProjectMember**: High Coupling. Acts as the associative entity (Join Table) binding `User` and `Project` with RBAC (`ProjectRole`).
    *   **OutboxEvent**: Decoupled. No foreign keys. Stores `jsonb` payload. Indicates an Event-Driven Architecture for cross-service consistency.

**4. SECURITY & COMPLIANCE**
*   **PII Exposure**: `User` entity contains `email`, `fullName`, `avatarUrl`.
*   **Auth Vectors**:
    *   `RefreshToken`: Hashed storage (`hashedToken`).
    *   `TwoFactorRecoveryCode`: Hashed storage (`hashedCode`).
    *   `User`: `passwordHash` stored.
*   **Access Control**: `ProjectMember` enforces `ProjectRole` (Manager/Agent). `Invitation` enforces token-based access.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Consistency/Naming]** - `backend/src/database/entities/outbox-event.entity.ts`: `aggregate_type`, `aggregate_id`, `event_type` -> **Strategy**: Rename properties to camelCase (`aggregateType`) and use `@Column({ name: 'aggregate_type' })` to match the codebase convention.
2.  **[Type Safety]** - `backend/src/database/entities/message.entity.ts`: `attachments: any | null` -> **Strategy**: Define a strict interface or DTO for attachments (e.g., `IMessageAttachment[]`) to prevent runtime errors when parsing JSONB.
3.  **[Type Safety/Precision]** - `backend/src/database/entities/message.entity.ts`: `id: number | string` (mapped to `bigint`) -> **Strategy**: Use `string` for `bigint` columns in TypeScript to avoid JavaScript `Number.MAX_SAFE_INTEGER` overflow, or use a transformer.
4.  **[Security/Configuration]** - `backend/src/database/data-source.ts`: Hardcoded fallbacks (`'hoang'`, `'your_database'`) -> **Strategy**: Remove hardcoded credentials. Throw error if environment variables are missing to prevent connecting to wrong DB in dev/prod mix-ups.
5.  **[SRP Violation]** - `backend/src/database/entities/user.entity.ts`: User entity handles Identity, 2FA, Profile, and App State -> **Strategy**: Extract 2FA logic to `UserSecuritySettings` entity or Value Object.
6.  **[Dead Code/Redundancy]** - `backend/src/database/entities/conversation.entity.ts`: `projectId` and `visitorId` columns defined twice (once as relation, once as explicit column) -> **Strategy**: While TypeORM allows this for optimization, ensure `relationId` loading is consistent. Explicit column definitions alongside relations can lead to sync issues if not managed correctly.

---

### Batch: Batch 2: Core Application Setup & Common Utilities
**Intent**: Ingest the main application entry point, core module, and essential common utilities, decorators, and middleware. This batch establishes how the application initializes and handles cross-cutting concerns like logging, encryption, and basic access control (RBAC).

**Files Analyzed**:
- `backend/src/main.ts`
- `backend/src/app.module.ts`
- `backend/src/app.service.ts`
- `backend/src/app.controller.ts`
- `backend/src/common/common.module.ts`
- `backend/src/common/decorators/get-current-user.decorator.ts`
- `backend/src/common/decorators/public.decorator.ts`
- `backend/src/common/middleware/logger.middleware.ts`
- `backend/src/common/services/encryption.service.ts`
- `backend/src/redis/redis.module.ts`
- `backend/src/rbac/rbac.module.ts`
- `backend/src/rbac/roles.decorator.ts`
- `backend/src/rbac/roles.guard.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & BOOTSTRAP**
*   **Framework**: NestJS (Monolithic).
*   **Entry Point**: `main.ts`. Initializes `NestFactory` with `bodyParser: false` (delegated to `body-parser` middleware).
*   **Infrastructure Integration**:
    *   **PostgreSQL**: Configured via `TypeOrmModule` (Async provider).
    *   **Redis**: Used for 3 distinct purposes:
        1.  **Caching**: `CacheModule` (global).
        2.  **Queues**: `BullModule` (BullMQ).
        3.  **Pub/Sub**: `RedisModule` exports `REDIS_PUBLISHER_CLIENT` and `REDIS_SUBSCRIBER_CLIENT` (ioredis).
    *   **WebSockets**: `RedisIoAdapter` configured in `main.ts` for horizontal scaling.
*   **Middleware Pipeline**: `LoggerMiddleware` (Custom) -> `json` -> `cookieParser` -> `ValidationPipe` (Global) -> `RolesGuard` (Global/Per-route).

**2. CONTROL FLOW & SECURITY**
*   **Authentication/Authorization**:
    *   **RBAC**: `RolesGuard` is defined but **CRITICALLY DISABLED**. `canActivate` returns `true` immediately; all logic is commented out.
    *   **User Context**: `GetCurrentUser` decorator retrieves `request.user` (assumed set by upstream `JwtAuthGuard`, not shown in this batch).
*   **Encryption**: `EncryptionService` implements AES-256-GCM.
    *   **Key Management**: Relies on `ENCRYPTION_KEY` (32 chars).
    *   **Vulnerability**: Constructor logs the raw `ENCRYPTION_KEY` to stdout if length validation fails.
*   **Logging**: `LoggerMiddleware` intercepts HTTP traffic.
    *   **Mechanism**: Monkey-patches `response.send` and `response.json` to capture response bodies. This is an invasive pattern compared to NestJS Interceptors.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Configuration**: `ConfigService` is the single source of truth for env vars.
    *   **Redis Connections**: `RedisModule` manages singleton `ioredis` clients.
    *   **Database Schema**: `TypeOrmModule` explicitly lists entities. `synchronize: false` indicates migration-based schema management (safer for prod).

*   **Mutation Risk**:
    *   **Response Object Mutation**: `LoggerMiddleware` alters the `Response` prototype methods. High risk of conflict with other libraries modifying the response stream (e.g., compression).
    *   **Security Bypass**: `RolesGuard` returning `true` unconditionally means all route-level `@Roles()` decorators are effectively ignored.

*   **Coupling & Cohesion**:
    *   **AppModule**: High Coupling. Acts as the central hub importing all feature modules (`Auth`, `User`, `Inbox`, etc.) and infrastructure modules.
    *   **RolesGuard**: High Coupling. Depends on `Reflector` (metadata) and `EntityManager` (direct DB access for Project roles).
    *   **RedisModule**: High Cohesion. Encapsulates Redis client creation and exports injection tokens.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical Security/Logic]** - `backend/src/rbac/roles.guard.ts`: `canActivate` returns `true` -> **Strategy**: Uncomment the logic or remove the guard if RBAC is handled elsewhere. Currently, this is a security placebo.
2.  **[Critical Security/Logging]** - `backend/src/common/services/encryption.service.ts`: `console.log('Provided ENCRYPTION_KEY:', secretKey)` -> **Strategy**: Remove logging of the secret key. Never output secrets to stdout/logs.
3.  **[Architectural Pattern]** - `backend/src/common/middleware/logger.middleware.ts`: Monkey-patching `res.send` -> **Strategy**: Replace with a NestJS `Interceptor` (`NestInterceptor`). Interceptors are the framework-native way to transform/log responses without modifying the underlying Express response object.
4.  **[Configuration/Security]** - `backend/src/app.module.ts`: Hardcoded DB credentials (`'hoang'`, `'your_database'`) -> **Strategy**: Remove string literals. Use `throw` if env vars are missing to prevent silent failures or connecting to wrong DBs.
5.  **[Dead Code]** - `backend/src/app.module.ts`: `ThrottlerModule` imports and configuration are commented out -> **Strategy**: Remove the commented-out code to reduce noise, or enable it if rate limiting is required.
6.  **[Type Safety]** - `backend/src/app.module.ts`: `parseInt(configService.get('REDIS_PORT') || '6379', 10)` -> **Strategy**: Use `Joi` or `class-validator` in `ConfigModule` to validate and transform environment variables at startup, removing inline parsing logic.

---

### Batch: Batch 3: User Management & Core Authentication
**Intent**: Focus on the core user management and authentication mechanisms, including user services, controllers, and various authentication strategies (local, JWT, refresh token, Google OAuth) and their associated guards. This forms a critical vertical slice for user interaction.

**Files Analyzed**:
- `backend/src/auth/auth.module.ts`
- `backend/src/auth/auth.service.ts`
- `backend/src/auth/auth.controller.ts`
- `backend/src/auth/strategies/local.strategy.ts`
- `backend/src/auth/strategies/jwt.strategy.ts`
- `backend/src/auth/strategies/refresh-token.strategy.ts`
- `backend/src/auth/strategies/google.strategy.ts`
- `backend/src/auth/strategies/google-link.strategy.ts`
- `backend/src/auth/guards/local-auth.guard.ts`
- `backend/src/auth/guards/jwt-auth.guard.ts`
- `backend/src/auth/guards/refresh-token.guard.ts`
- `backend/src/user/user.module.ts`
- `backend/src/user/user.service.ts`
- `backend/src/user/user.controller.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & AUTHENTICATION FLOWS**
*   **Module Architecture**:
    *   `AuthModule`: Orchestrator. Imports `UserModule`, `PassportModule`, `JwtModule`, `MailModule`.
    *   **State Management**: Hybrid.
        *   **Persistent**: PostgreSQL (`User`, `RefreshToken`, `UserIdentity`, `TwoFactorRecoveryCode`).
        *   **Ephemeral**: Redis (`CACHE_MANAGER`). Used for:
            *   Email Verification Tokens (15m TTL).
            *   Password Reset Tokens (15m TTL).
            *   OAuth One-Time Codes (5m TTL).
            *   Email Change Tokens (24h TTL).
            *   Pending Invitations (7d TTL).
*   **Token Strategy**:
    *   **Access Token**: JWT (Bearer). Stateless verification via `JwtStrategy`. Revocable via `User.tokensValidFrom` timestamp check.
    *   **Refresh Token**: JWT (Cookie: `refresh_token`). Stateful verification via `RefreshTokenStrategy` + DB lookup. Stored as **bcrypt hash** in DB.
    *   **2FA Token**: Partial JWT (`is2FA: true`). Used as intermediate state before full session grant.
*   **OAuth Implementation**:
    *   **Flow**: `GoogleStrategy` -> Callback -> `AuthService.generateOneTimeCode` (Redis) -> Frontend Redirect -> Frontend calls `exchange-code` -> Full Tokens.
    *   **Account Linking**: `GoogleLinkStrategy` allows attaching Google identity to existing authenticated sessions.

**2. CONTROL FLOW & LOGIC GRAPH**
*   **Login Sequence**:
    1.  `LocalAuthGuard` -> `LocalStrategy` -> `AuthService.validateUser`.
    2.  `AuthController.login` checks `isTwoFactorAuthenticationEnabled`.
    3.  **Branch A (No 2FA)**: `AuthService.loginAndReturnTokens` -> Generates JWTs -> Hashes Refresh Token -> Stores in DB -> Returns JSON + Cookie.
    4.  **Branch B (2FA)**: `AuthService.generate2FAPartialToken` -> Returns 401 with `2FA_REQUIRED` + Partial Token Cookie.
*   **Refresh Sequence**:
    1.  `RefreshTokenGuard` -> `RefreshTokenStrategy` -> Extracts Cookie.
    2.  `UserService.verifyRefreshToken`: **Linear Scan** (O(N)) of user's stored hashes to find match.
    3.  **Rotation**: If valid, deletes old token, generates new pair, stores new hash.
*   **Email Change Sequence**:
    1.  `request-email-change`: Verifies password -> Generates Token -> Redis Store -> Sends Email to NEW address.
    2.  `verify-email-change`: Validates Token -> Updates `User.email` -> **Side Effect**: Unlinks all OAuth providers (security measure) -> Invalidates all sessions.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **User Identity**: Owned by `UserService` (PostgreSQL).
    *   **Session State**: Shared. `AuthService` generates tokens; `UserService` persists/validates them.
    *   **Auth Transaction State**: Owned by `AuthService` via Redis (verification codes, state parameters).

*   **Mutation Risk**:
    *   **Session Invalidation**: `UserService.verifyEmailChange` triggers a massive side effect: `DELETE FROM user_identity` and `DELETE FROM refresh_token`. This is a high-impact mutation ensuring security but potentially confusing users if not communicated (OAuth unlinking).
    *   **Token Revocation**: `User.tokensValidFrom` is a "Nuclear Option" invalidating *all* JWTs issued before that timestamp. Used in Password Reset and Logout All.

*   **Coupling & Cohesion**:
    *   **AuthService**: **Low Cohesion (God Class)**. Handles Registration, Login, OAuth, Password Reset, 2FA, and Token Rotation.
    *   **UserService**: **High Coupling**. Tightly bound to `AuthService` logic (e.g., `verifyRefreshToken` logic resides here but is purely auth-concerns).
    *   **Redis Dependency**: Critical path dependency. Registration and Password Reset *fail* if Redis is down.

*   **Security Analysis**:
    *   **Critical Vulnerability**: `AuthController.exchangeCode` logs **Raw Access and Refresh Tokens** to stdout.
    *   **Token Storage**: Refresh tokens are hashed (bcrypt), mitigating database leak risks.
    *   **Session Limit**: Enforced in `UserService.setCurrentRefreshToken` (Limit: 5). Oldest tokens are rotated out.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical Security/Logging]** - `backend/src/auth/auth.controller.ts`: `console.log('Access Token:', accessToken)` -> **Strategy**: **IMMEDIATE REMOVAL**. Never log raw tokens or PII to stdout/logs.
2.  **[SRP Violation]** - `backend/src/auth/auth.service.ts`: ~700 lines handling 5 distinct domains (Local, OAuth, Password, Token, 2FA) -> **Strategy**: Split into `LocalAuthService`, `OAuthService`, `TokenService`, and `PasswordService`.
3.  **[Algorithmic Inefficiency]** - `backend/src/user/user.service.ts`: `verifyRefreshToken` performs O(N) bcrypt comparisons -> **Strategy**: Include a unique `tokenId` (UUID) in the Refresh Token JWT payload. Store `tokenId` in DB. Lookup by ID (O(1)) then verify hash.
4.  **[Leaky Abstraction]** - `backend/src/user/user.service.ts`: `verifyRefreshToken` -> **Strategy**: Move token verification logic to `TokenService` (extracted from AuthService). `UserService` should only provide data access, not implement auth verification logic.
5.  **[Dead Code/Redundancy]** - `backend/src/auth/auth.service.ts`: `logout` method iterates tokens to find match -> **Strategy**: If `tokenId` strategy (point 3) is adopted, logout becomes a direct delete by ID.
6.  **[Hardcoded Configuration]** - `backend/src/user/user.service.ts`: `sessionLimit` defaults to 5 inside the method -> **Strategy**: Move default value to `ConfigService` or a constant definition file to centralize configuration.
7.  **[Type Safety]** - `backend/src/auth/strategies/refresh-token.strategy.ts`: Manual Regex check for UUID -> **Strategy**: Use `class-validator` or `ParseUUIDPipe` logic if possible, though inside a strategy manual check is acceptable, it duplicates validation logic found elsewhere.

---

### Batch: Batch 4: Two-Factor Authentication & Mail Service
**Intent**: Extend the authentication understanding to include two-factor authentication (2FA) and the mail service, which is often a dependency for 2FA, password resets, and user notifications. This builds on the core authentication logic.

**Files Analyzed**:
- `backend/src/auth/2fa/two-factor-authentication.controller.ts`
- `backend/src/auth/2fa/two-factor-authentication.service.ts`
- `backend/src/auth/strategies/2fa-partial-token.strategy.ts`
- `backend/src/mail/mail.module.ts`
- `backend/src/mail/mail.service.ts`
- `backend/src/mail/mail.controller.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & 2FA STATE MACHINE**
*   **Authentication State Machine**:
    *   **State 0 (Unauthenticated)**: No tokens.
    *   **State 1 (Partial/Intermediate)**: Valid credentials provided. Server issues `2fa_partial_token` (Cookie). User identity known (`sub`), but `isTwoFactorAuthenticated: false`.
    *   **State 2 (Authenticated)**: Valid 2FA code provided. Server issues `access_token` + `refresh_token`. `isTwoFactorAuthenticated: true`.
*   **Infrastructure Dependencies**:
    *   **Mail**: `Nodemailer` (SMTP). Synchronous send within async wrapper.
    *   **Crypto**: `otplib` (TOTP generation/verification), `qrcode` (Visual rendering).
    *   **Storage**:
        *   **Ephemeral**: `2fa_secret` cookie (encrypted, 5m TTL) during setup.
        *   **Persistent**: `User.twoFactorAuthenticationSecret` (encrypted) in PostgreSQL.

**2. CONTROL FLOW & LOGIC GRAPH**
*   **2FA Setup Flow**:
    1.  `POST /2fa/generate`: Generates TOTP secret -> Encrypts -> Sets `2fa_secret` cookie -> Returns QR Data URL.
    2.  `POST /2fa/turn-on`: Reads `2fa_secret` cookie -> Decrypts -> Verifies User Code -> Calls `UserService.turnOn...` (Persist) -> Clears cookie -> Returns Recovery Codes.
*   **2FA Login Flow**:
    1.  **Upstream**: `AuthService` detects 2FA enabled -> Returns `2fa_partial_token`.
    2.  `POST /2fa/authenticate`:
        *   **Guard**: `AuthGuard('2fa-partial')` validates cookie & ensures `isTwoFactorAuthenticated` is false.
        *   **Logic**: Fetch User -> Decrypt stored secret -> Verify Code -> **Session Upgrade**.
        *   **Session Upgrade**: Calls `AuthService.loginAndReturnTokens` -> Manually sets `refresh_token` cookie -> Returns JSON.
*   **Mail Dispatch**:
    *   Direct invocation via `MailService`.
    *   **Templates**: Hardcoded HTML strings within service methods (`sendUserConfirmation`, `sendEmailChangeVerification`).

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **2FA Secret (Pending)**: Client-side ownership (Encrypted Cookie). Server is stateless regarding pending 2FA setups.
    *   **2FA Secret (Active)**: `User` Entity (Database).
    *   **Mail Configuration**: `ConfigService` (Environment Variables).

*   **Mutation Risk**:
    *   **Cookie Management**: `TwoFactorAuthenticationController` manually manages cookie lifecycles (`res.cookie`, `res.clearCookie`). Logic for `refresh_token` cookie attributes (SameSite, Secure, Expires) is duplicated here, diverging from `AuthController`.
    *   **Open Relay Risk**: `MailController.sendTestEmail` accepts an arbitrary `to` address without authentication guards shown in the snippet. Potential spam vector.

*   **Coupling & Cohesion**:
    *   **TwoFactorAuthenticationController**: **High Coupling**. Orchestrates `UserService` (DB), `AuthService` (Tokens), `EncryptionService` (Security), and `ConfigService` (Env). It acts as a "mini-AuthService".
    *   **MailService**: **Low Cohesion**. Mixes **Transport Logic** (SMTP connection) with **Presentation Logic** (HTML Template construction). Changing email design requires modifying the service logic.

*   **Security Analysis**:
    *   **PII Leakage**: `TwoFactorAuthenticationController.authenticate` logs `req.user`, `user.email`, and `user` object to stdout.
    *   **Encryption**: Correctly encrypts TOTP secrets at rest and in transit (cookies).
    *   **Token Isolation**: `TwoFactorAuthenticationStrategy` explicitly rejects tokens where `isTwoFactorAuthenticated: true`, preventing full access tokens from accessing the 2FA handshake endpoint.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical Security/Logging]** - `backend/src/auth/2fa/two-factor-authentication.controller.ts`: `console.log('Request user:', req.user)`, `console.log('Found user:', user)` -> **Strategy**: **IMMEDIATE REMOVAL**. Logging user objects exposes PII and potentially hashed passwords/secrets to logs.
2.  **[Security/Access Control]** - `backend/src/mail/mail.controller.ts`: `sendTestEmail(@Body('to') to: string)` -> **Strategy**: Remove this endpoint or wrap it in `DevModeGuard`. It allows unauthenticated users to send emails via the system's SMTP credentials.
3.  **[SRP Violation/Hardcoding]** - `backend/src/mail/mail.service.ts`: HTML strings embedded in methods -> **Strategy**: Extract to `EmailTemplateService` or use a template engine (Handlebars/EJS). Service should only handle transport, not content generation.
4.  **[DRY Violation/Fragility]** - `backend/src/auth/2fa/two-factor-authentication.controller.ts`: Manual parsing of `JWT_REFRESH_EXPIRES_IN` (`parseInt(str.slice(0, -1))`) and cookie setting logic -> **Strategy**: Centralize cookie configuration and token parsing in `AuthService` or a `CookieManager` utility to ensure consistency between `AuthController` and `TwoFactorAuthenticationController`.
5.  **[Type Safety]** - `backend/src/auth/2fa/two-factor-authentication.controller.ts`: `user as any` in `generate` method -> **Strategy**: Define a proper interface for the User object expected by `generateSecret` (e.g., `Pick<User, 'email'>`) to avoid `any` casting.
6.  **[Architecture/Coupling]** - `backend/src/auth/2fa/two-factor-authentication.controller.ts`: Controller contains business logic for verifying user existence and 2FA status -> **Strategy**: Move the verification and "Session Upgrade" logic into `TwoFactorAuthenticationService`. The controller should only handle HTTP I/O.

---

### Batch: Batch 5: Eventing System (Producer & Consumer)
**Intent**: Analyze the asynchronous communication layer, including event producers (BullMQ), event consumers, outbox pattern listeners, and the worker process. This reveals how background tasks and inter-service communication are handled.

**Files Analyzed**:
- `backend/src/event-producer/event-producer.module.ts`
- `backend/src/event-producer/bullmq-producer.service.ts`
- `backend/src/event-consumer/event-consumer.module.ts`
- `backend/src/event-consumer/event-consumer.service.ts`
- `backend/src/event-consumer/event.processor.ts`
- `backend/src/event-consumer/outbox-listener.service.ts`
- `backend/src/worker.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & EVENT ARCHITECTURE**
*   **Architecture Pattern**: **Transactional Outbox** combined with **Asynchronous Workers**.
    *   **Ingress (Async)**: `BullMqProducerService` pushes jobs to Redis (`live-chat-events-queue`).
    *   **Processing (Worker)**: `EventProcessor` (BullMQ Worker) consumes jobs -> Delegates to `EventConsumerService`.
    *   **Persistence (Atomic)**: `EventConsumerService` executes a single transaction:
        1.  Find/Create `Visitor` & `Conversation`.
        2.  Create `Message`.
        3.  Insert `OutboxEvent` (SQL Insert).
    *   **Egress (Real-time)**: `OutboxListenerService` listens to PostgreSQL `NOTIFY` -> Locks rows (`FOR UPDATE SKIP LOCKED`) -> Publishes to Redis Pub/Sub (`new_message_channel`) -> Deletes rows.
*   **Infrastructure**:
    *   **Redis**: Dual role. 1. BullMQ Storage. 2. Pub/Sub for Outbox propagation.
    *   **PostgreSQL**: Uses `LISTEN/NOTIFY` mechanism for low-latency event signaling.
    *   **Worker Process**: `worker.ts` initializes a standalone NestJS context, decoupled from the HTTP API.

**2. CONTROL FLOW & LOGIC GRAPH**
*   **Event Consumption Flow**:
    1.  `EventProcessor.process()` receives job.
    2.  Calls `EventConsumerService.processEvent()`.
    3.  **Branch**: If `NEW_MESSAGE_FROM_VISITOR`:
        *   Opens Transaction.
        *   Orchestrates `VisitorService`, `ConversationService`, `MessageService`.
        *   **Side Effect**: Writes to `outbox_events` table.
*   **Outbox Propagation Flow**:
    1.  `OutboxListenerService` initializes -> Connects to raw Postgres driver -> Executes `LISTEN outbox_channel`.
    2.  **Trigger**: `NOTIFY` received OR 60s polling fallback.
    3.  **Process**:
        *   Transaction Start.
        *   `SELECT ... FOR UPDATE SKIP LOCKED` (Concurrency safe).
        *   Iterate Events -> `redisPublisher.publish()`.
        *   `DELETE FROM outbox_events`.
        *   Commit.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Job State**: Owned by BullMQ (Redis).
    *   **Consistency State**: Owned by PostgreSQL Transaction. The `Message` and the `OutboxEvent` are guaranteed to exist together or not at all.
    *   **Listener State**: `OutboxListenerService` holds a persistent raw TCP connection to Postgres for `LISTEN`.

*   **Mutation Risk**:
    *   **Raw SQL Injection Risk**: `EventConsumerService` uses parameterized queries (`$1, $2...`), which is safe, but bypassing the ORM for `OutboxEvent` insertion reduces type safety and maintainability.
    *   **Data Loss**: `OutboxListenerService` performs a hard `DELETE` after publishing. There is no historical record of processed events. If the Redis Publish succeeds but the Commit fails (rare), events might be re-processed (At-Least-Once delivery), which is acceptable but requires idempotency downstream.
    *   **Driver Coupling**: `(queryRunner.connection.driver as any).master` accesses private internal properties of the TypeORM/pg driver. This is highly brittle and will break if the underlying library changes its internal structure.

*   **Coupling & Cohesion**:
    *   **EventConsumerService**: **High Coupling**. It acts as a "God Service" for chat logic, importing services from `InboxModule` and manually managing transactions across them.
    *   **OutboxListenerService**: **High Cohesion**. Strictly handles the reliable propagation of DB events to Redis.
    *   **Worker**: **Decoupled**. Can scale independently of the main API application.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical/Fragility]** - `backend/src/event-consumer/outbox-listener.service.ts`: `(queryRunner.connection.driver as any).master` -> **Strategy**: Use a dedicated `pg` client instance for `LISTEN/NOTIFY` instead of hacking the TypeORM connection internals. TypeORM does not officially support `LISTEN` on its managed connections.
2.  **[Consistency/ORM]** - `backend/src/event-consumer/event-consumer.service.ts`: Raw SQL `INSERT INTO outbox_events` -> **Strategy**: Inject `Repository<OutboxEvent>` and use `manager.save(OutboxEvent, entity)` within the transaction. This ensures entity hooks and validation run, and adheres to the project's ORM pattern.
3.  **[Type Safety]** - `backend/src/event-consumer/event-consumer.service.ts`: `processEvent(event: any)` -> **Strategy**: Define a Discriminated Union type for Events (e.g., `type AppEvent = { type: 'NEW_MESSAGE_FROM_VISITOR', payload: MessagePayload } | ...`) to enforce payload structure at compile time.
4.  **[Configuration/Hardcoding]** - `backend/src/event-consumer/outbox-listener.service.ts`: `'outbox_channel'`, `'new_message_channel'` -> **Strategy**: Move these magic strings to a shared `Constants` file or `ConfigService`. Mismatches here cause silent system failures.
5.  **[Observability/Data Loss]** - `backend/src/event-consumer/outbox-listener.service.ts`: `DELETE FROM outbox_events` -> **Strategy**: Consider a soft delete or moving processed events to an `outbox_events_archive` table if audit trails are required. Hard delete destroys evidence of event propagation.
6.  **[Dead Code/Comments]** - `backend/src/event-consumer/event.processor.ts`: Extensive commented-out logic regarding payload parsing -> **Strategy**: Remove commentary. Ensure the contract between Producer and Consumer is strict (JSON object) and documented in types.

---

### Batch: Batch 6: Realtime Gateway & Inbox Feature
**Intent**: Examine the real-time communication infrastructure (WebSocket gateway, Redis adapter) and a key feature leveraging it: the inbox. This batch demonstrates how real-time updates are managed and integrated into a user-facing feature.

**Files Analyzed**:
- `backend/src/gateway/gateway.module.ts`
- `backend/src/gateway/events.gateway.ts`
- `backend/src/gateway/guards/ws-jwt-auth.guard.ts`
- `backend/src/gateway/redis-io.adapter.ts`
- `backend/src/inbox/inbox.module.ts`
- `backend/src/inbox/inbox.controller.ts`
- `backend/src/inbox/events.ts`
- `backend/src/inbox/inbox-event.handler.ts`
- `backend/src/inbox/services/conversation.service.ts`
- `backend/src/inbox/services/message.service.ts`
- `backend/src/inbox/services/visitor.service.ts`
- `backend/src/realtime-session/realtime-session.module.ts`
- `backend/src/realtime-session/realtime-session.service.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & REAL-TIME INFRASTRUCTURE**
*   **Protocol**: WebSocket (Socket.IO) via `EventsGateway`.
*   **Scaling Strategy**: Horizontal scaling enabled via `RedisIoAdapter`.
    *   **Mechanism**: Uses `redis-adapter` to broadcast events across multiple server instances.
    *   **Pub/Sub**: `REDIS_SUBSCRIBER_CLIENT` listens to `new_message_channel` to bridge the gap between the Event Worker (Batch 5) and connected WebSockets.
*   **Session Management**: `RealtimeSessionService` (Redis-backed).
    *   **Mapping**: `visitorUid` -> `socketId`.
    *   **Constraint**: 1:1 mapping. If a visitor opens multiple tabs, the last connection overwrites the session key, potentially disconnecting or silencing previous tabs.
*   **Security Boundary**:
    *   **Agents**: Authenticated via `WsJwtAuthGuard` (JWT in handshake auth).
    *   **Visitors**: Authenticated via Origin validation in `RedisIoAdapter`.
        *   **Logic**: Checks `Origin` header against `Project.whitelistedDomains` in the database.

**2. CONTROL FLOW & DATA PATHS**
*   **Visitor Ingress (Message)**:
    1.  Socket `sendMessage` -> `EventsGateway`.
    2.  Emits internal event `visitor.message.received`.
    3.  `InboxEventHandlerService` handles event -> Pushes to BullMQ (`BullMqProducerService`).
    4.  (Async Processing & DB Insert happens in Worker - Batch 5).
*   **Agent Ingress (Reply)**:
    1.  HTTP `POST /conversations/:id/messages` -> `InboxController`.
    2.  `MessageService.sendAgentReply` -> DB Transaction (Insert Message).
    3.  **Side Effect**: Calls `EventsGateway.sendReplyToVisitor` (Direct Socket Emit).
    4.  Updates Message Status (`SENT`/`DELIVERED`) -> DB Update.
*   **Event Propagation (The Loop)**:
    1.  **Source**: Redis Pub/Sub (`new_message_channel`) triggered by `OutboxListener` (Batch 5).
    2.  **Sink**: `EventsGateway` subscribes to channel.
    3.  **Distribution**:
        *   **To Agent**: Emits to Room `project:{projectId}`.
        *   **To Visitor**: Lookup `socketId` via `RealtimeSessionService` -> Emit to specific socket.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Connection State**: `socket.data` holds `projectId`, `visitorUid`, `user`. Ephemeral (Memory).
    *   **Routing State**: `RealtimeSessionService` owns the routing table (`visitorUid` -> `socketId`) in Redis.
    *   **Business State**: `ConversationService` owns the persistent chat history in PostgreSQL.

*   **Mutation Risk**:
    *   **Adapter Logic**: `RedisIoAdapter` performs a blocking DB query (`projectService.findByProjectId`) during the handshake phase. This occurs *before* the connection is fully established. High latency here impacts connection time; DB downtime causes global WebSocket outage.
    *   **Race Condition**: `MessageService.sendAgentReply` updates the message status *after* emitting to the socket. If the server crashes between emit and save, the DB shows `SENDING` while the user received the message.

*   **Coupling & Cohesion**:
    *   **RedisIoAdapter**: **Low Cohesion**. It mixes Infrastructure concerns (Redis connection) with Domain Logic (CORS Whitelisting, Project Lookup).
    *   **InboxEventHandlerService**: **High Coupling**. Acts as a mediator between `EventsGateway`, `BullMqProducer`, `ConversationService`, and `VisitorService`.
    *   **Circular Dependency**: `MessageService` depends on `EventsGateway`. `EventsGateway` depends on `RealtimeSessionService`. `InboxModule` manages this via `forwardRef`, indicating architectural tension.

*   **Security Analysis**:
    *   **PII Leakage**: `EventsGateway` logs `socket.onAny` args. This logs **all message content** to stdout/logs.
    *   **Origin Validation**: Implemented manually in `RedisIoAdapter`. While functional, it bypasses standard NestJS/Express CORS middleware, creating a split security model.
    *   **Authorization**: `WsJwtAuthGuard` correctly attaches `user` to `client.data`, but `EventsGateway` methods (e.g., `handleSendMessage`) rely on `client.data.visitorUid` without re-verifying ownership, assuming the handshake validation holds.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical Security/Logging]** - `backend/src/gateway/events.gateway.ts`: `socket.onAny(...)` logs all arguments -> **Strategy**: **IMMEDIATE REMOVAL**. This logs every chat message content to the application logs, violating privacy/compliance (GDPR/HIPAA).
2.  **[Architectural Violation]** - `backend/src/gateway/redis-io.adapter.ts`: DB logic (`projectService.findByProjectId`) inside IO Adapter -> **Strategy**: Move validation logic to a `ConnectionGuard` or `Gateway`'s `handleConnection`. Adapters should only handle transport/protocol, not business rules.
3.  **[Performance/Scalability]** - `backend/src/gateway/redis-io.adapter.ts`: Synchronous DB query on every handshake -> **Strategy**: Cache Project Whitelists in Redis. Handshake should hit Redis, not Postgres.
4.  **[Type Safety]** - `backend/src/gateway/events.gateway.ts`: `sendReplyToVisitor(..., message: any)` -> **Strategy**: Define `MessageDto` or use the Entity type. `any` bypasses compile-time checks for payload structure.
5.  **[Dead Code/Debug]** - `backend/src/inbox/inbox.controller.ts`: `console.log` usage in `listConversations` -> **Strategy**: Remove console logs. Use `Logger` service if debug info is needed, but ensure PII is scrubbed.
6.  **[Race Condition/Consistency]** - `backend/src/inbox/services/message.service.ts`: `sendAgentReply` saves, emits, then saves again -> **Strategy**: Optimistic UI updates on frontend should handle the "Sending" state. Backend should commit the message as "Sent" in one transaction if possible, or accept that "Sending" status might persist on crash.
7.  **[Concurrency]** - `backend/src/realtime-session/realtime-session.service.ts`: `setVisitorSession` overwrites key -> **Strategy**: Use a Redis Set (`SADD`) to store multiple socket IDs per visitor if multi-tab support is desired, then broadcast to all sockets in the set.

---

### Batch: Batch 7: Projects Feature
**Intent**: Ingest the modules, services, and controllers related to the 'Projects' feature, including project management and invitations. This provides a vertical slice of a core business domain.

**Files Analyzed**:
- `backend/src/projects/project.module.ts`
- `backend/src/projects/project.service.ts`
- `backend/src/projects/project.controller.ts`
- `backend/src/projects/public-project.controller.ts`
- `backend/src/projects/invitation.service.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & DOMAIN MODEL**
*   **Domain Boundaries**:
    *   **Project Core**: `Project` (Aggregate Root), `ProjectMember` (Associative Entity).
    *   **Onboarding**: `Invitation` (Ephemeral State).
    *   **Public Access**: Widget Settings (Origin-gated).
*   **Persistence Strategy**:
    *   **Transactional Integrity**: Used in `ProjectService.create` (Project + Owner Member) and `InvitationService.acceptInvitation` (Member + Invitation Status).
    *   **Relations**: Explicit loading via `relations: ['project', 'project.members']`.
*   **Access Control Model**:
    *   **Hierarchical**: `RolesGuard` (Controller Level) + `validateProjectMembership` (Service Level).
    *   **Invitation Security**: Token-based (32-byte hex). Bound to `email`. Validates `user.email === invitation.email` upon acceptance to prevent hijacking.

**2. CONTROL FLOW & LOGIC GRAPH**
*   **Invitation Lifecycle**:
    1.  **Creation**: Manager requests -> Validates Role -> Checks Duplicates (Member/Pending) -> Generates Token -> Persists -> **Side Effect** (Email).
    2.  **Consumption**:
        *   **New User**: Register -> `getInvitationByToken` (Public) -> Pre-fill.
        *   **Existing User**: Login -> `acceptInvitation` (Auth).
    3.  **Acceptance Logic**:
        *   Validate Token & Expiry.
        *   **Critical Check**: Match Session User Email vs Invitation Email.
        *   **Atomic Commit**: Insert `ProjectMember` + Update `Invitation` status.
*   **Widget Configuration**:
    *   **Ingress**: `PublicProjectController` -> `ProjectService.getWidgetSettings`.
    *   **Gatekeeper**: "Fail-Closed" Origin Validation.
        *   If `Origin` header missing -> Deny.
        *   If `whitelistedDomains` empty -> Deny.
        *   If `Origin` not in whitelist -> Deny.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Project State**: Owned by `ProjectService`.
    *   **Invitation State**: Owned by `InvitationService`.
    *   **Membership State**: Shared. Created by `ProjectService` (on project creation) and `InvitationService` (on acceptance).

*   **Mutation Risk**:
    *   **Orphaned Records**: In `createInvitation`, `entityManager.save(invitation)` occurs *before* `sendInvitationEmail`. If the mailer fails, a pending invitation exists in DB but the user never received the token.
    *   **Race Conditions**: `InvitationService.createInvitation` performs "Check-then-Act" (Select `existingInvitation` -> Save). Without a unique database constraint on `(email, projectId, status=PENDING)`, concurrent requests could create duplicate pending invitations.

*   **Coupling & Cohesion**:
    *   **InvitationService**: **Low Cohesion**. Mixes Domain Logic (Token generation, DB ops) with Presentation Logic (HTML Email construction).
    *   **ProjectController**: **Low Cohesion**. Acts as a "Kitchen Sink" controller handling Project CRUD, Widget Settings, *and* Invitation management (delegating to `InvitationService`).
    *   **ProjectService**: **High Coupling**. Tightly coupled to `ProjectMember` for authorization checks.

*   **Security Analysis**:
    *   **Critical Information Leak**: `InvitationService` logs the full `invitationUrl` (containing the secret token) to stdout.
    *   **PII Exposure**: `acceptInvitation` logs `user.email` and `userId`.
    *   **Authorization Bypass Risk**: `InvitationService.createInvitation` manually re-implements the "Is Manager" check (`inviterMembership.role !== ProjectRole.MANAGER`) instead of reusing `ProjectService.validateProjectMembership` or a shared policy.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical Security/Logging]** - `backend/src/projects/invitation.service.ts`: `this.logger.log(..., invitationUrl)` -> **Strategy**: **IMMEDIATE REMOVAL**. Logging the invitation URL leaks the authentication token to logs (Splunk/CloudWatch), allowing anyone with log access to hijack the invitation.
2.  **[SRP Violation/Hardcoding]** - `backend/src/projects/invitation.service.ts`: `sendInvitationEmail` contains embedded HTML -> **Strategy**: Extract to `EmailTemplateService` or use a template engine. Service should handle *logic*, not *markup*.
3.  **[DRY Violation/Security]** - `backend/src/projects/invitation.service.ts`: Manual query for `ProjectMember` to check Manager role -> **Strategy**: Inject `ProjectService` and call `validateProjectMembership` (refactored to support role checks). Centralize authorization logic to prevent inconsistencies.
4.  **[Type Safety]** - `backend/src/projects/invitation.service.ts`: `getInvitationByToken` returns `Promise<any>` -> **Strategy**: Define a DTO (e.g., `InvitationDetailsDto`) to enforce the shape of the response (Invitation + Project Name).
5.  **[Controller Cohesion]** - `backend/src/projects/project.controller.ts`: Handles `/projects/:id/invitations` -> **Strategy**: Move invitation-related endpoints to a dedicated `InvitationController` (`@Controller('projects/:projectId/invitations')` or similar). `ProjectController` is becoming a God Controller.
6.  **[Dead Code]** - `backend/src/projects/project.controller.ts`: `@Throttle` decorator is commented out -> **Strategy**: Remove dead code or enable it. Commented-out security features create a false sense of security or clutter.
7.  **[Consistency]** - `backend/src/projects/project.service.ts`: `update` uses `Object.assign` while `updateWidgetSettings` uses spread syntax -> **Strategy**: Standardize on one update pattern (preferably spread or individual field assignment for type safety) to avoid accidental prototype pollution or overwriting protected fields.

---

### Batch: Batch 8: Remaining Features (Billing, Usage, Screenshot)
**Intent**: Cover the remaining distinct feature modules such as billing, usage tracking, and screenshot generation. These are often more self-contained or depend on the foundational services already covered.

**Files Analyzed**:
- `backend/src/billing/billing.module.ts`
- `backend/src/usage/usage.module.ts`
- `backend/src/screenshot/screenshot.controller.ts`
- `backend/src/screenshot/screenshot.service.ts`
- `backend/src/screenshot/utils.module.ts`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM TOPOLOGY & MODULE STRUCTURE**
*   **Module Boundaries**:
    *   `UtilsModule`: Encapsulates utility features, currently only **Screenshot Generation**.
    *   `BillingModule`: **Empty Shell**. Defined but contains no logic, providers, or controllers.
    *   `UsageModule`: **Empty Shell**. Defined but contains no logic.
*   **Infrastructure Dependencies**:
    *   **Puppeteer**: Headless Chrome automation for rendering web pages.
    *   **Node.js URL API**: Used for parsing and validating query parameters.
    *   **In-Memory Cache**: Ad-hoc `Map<string, ...>` implementation for caching screenshots.

**2. CONTROL FLOW & LOGIC GRAPH**
*   **Screenshot Request Flow**:
    1.  **Ingress**: `GET /utils/screenshot?url=...` -> `ScreenshotController`.
    2.  **Validation**:
        *   Decodes URI component.
        *   Parses via `new URL()`.
        *   Protocol Check: Whitelists `http:` and `https:`.
    3.  **Service Delegation**: Calls `ScreenshotService.getScreenshot`.
    4.  **Cache Check**:
        *   Look up URL in module-level `screenshotCache`.
        *   If hit & TTL < 60s -> Return Buffer.
    5.  **Execution (Cache Miss)**:
        *   **Heavy Operation**: `puppeteer.launch()` (Spawns new Chrome process).
        *   `page.goto(url)` with 15s timeout.
        *   `page.screenshot()`.
        *   `browser.close()` (Critical resource cleanup).
    6.  **Egress**: Wraps Buffer in `StreamableFile` -> Pipes to HTTP Response.

**3. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Global State**: `screenshotCache` is defined at the **module scope** (outside the class), not as a class property. It acts as a singleton cache across all service instances (though the service is likely a singleton).
    *   **Process State**: Each request spawns a completely new OS-level Browser process.

*   **Mutation Risk**:
    *   **Memory Leak**: The `screenshotCache` (`Map`) has **no eviction policy** (no max size). It only checks TTL on access. An attacker requesting unique URLs can exhaust server memory (DoS).
    *   **Resource Exhaustion**: Launching a browser instance per request is extremely CPU/RAM intensive. Concurrent requests will likely crash the host or cause timeouts.

*   **Security Analysis (SSRF)**:
    *   **Vulnerability**: Server-Side Request Forgery (SSRF). While the protocol is restricted to `http/s`, there is **no validation of the destination hostname**.
    *   **Vector**: An attacker can request screenshots of:
        *   `http://localhost:xxxx` (Internal services).
        *   `http://169.254.169.254/...` (Cloud Metadata services, exposing AWS/GCP credentials).
        *   Internal network endpoints.

*   **Coupling & Cohesion**:
    *   `UtilsModule`: **Low Cohesion**. Naming suggests a "junk drawer" for unrelated utilities. Should be `ScreenshotModule`.
    *   `ScreenshotService`: **High Cohesion** internally, but tightly coupled to the specific `puppeteer` implementation details.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical Security/SSRF]** - `backend/src/screenshot/screenshot.controller.ts`: URL validation only checks protocol -> **Strategy**: Implement a **Blocklist/Allowlist** for hostnames. Reject `localhost`, `127.0.0.1`, `0.0.0.0`, `169.254.x.x`, and private IP ranges (RFC 1918) to prevent internal network scanning.
2.  **[Critical Performance/DoS]** - `backend/src/screenshot/screenshot.service.ts`: `puppeteer.launch()` per request -> **Strategy**: Use a **Browser Pool** (e.g., `puppeteer-cluster` or a singleton browser instance) to reuse the browser process. Spawning Chrome per request is not scalable.
3.  **[Memory Leak]** - `backend/src/screenshot/screenshot.service.ts`: `const screenshotCache = new Map(...)` -> **Strategy**: Replace with `lru-cache` or Redis. The current `Map` grows indefinitely with unique URLs, leading to OOM (Out of Memory) crashes.
4.  **[Dead Code]** - `backend/src/billing/billing.module.ts` & `backend/src/usage/usage.module.ts`: Empty modules -> **Strategy**: Delete these files if they are not used, or implement the required logic. Empty modules add noise to the dependency graph.
5.  **[Architecture/Naming]** - `backend/src/screenshot/utils.module.ts`: Named `UtilsModule` but only imports Screenshot components -> **Strategy**: Rename to `ScreenshotModule` to reflect its actual responsibility and adhere to the Principle of Least Surprise.
6.  **[Global State]** - `backend/src/screenshot/screenshot.service.ts`: `screenshotCache` defined in file scope -> **Strategy**: Move cache inside the `ScreenshotService` class (as a private property) or inject a dedicated `CacheService`. Global variables make testing and state management brittle.

---

### Batch: Batch 9: Configuration, Infrastructure & Tests
**Intent**: Finally, ingest configuration files, infrastructure scripts (AWS, Localstack, Docker Compose), development setup (ESLint, TSConfig), and test files. These provide context for deployment, development practices, and system validation.

**Files Analyzed**:
- `backend/.env.example`
- `backend/aws/install`
- `backend/aws/README.md`
- `backend/aws/THIRD_PARTY_LICENSES`
- `backend/compose-backup.yaml`
- `backend/compose.yaml`
- `backend/eslint.config.mjs`
- `backend/GEMINI.md`
- `backend/localstack-init/init-aws.sh`
- `backend/nest-cli.json`
- `backend/package.json`
- `backend/README.md`
- `backend/tsconfig.build.json`
- `backend/tsconfig.json`
- `backend/tsconfig.tsbuildinfo`
- `backend/tsconfig.worker.json`
- `backend/tsconfig.worker.tsbuildinfo`
- `backend/src/auth/LINK_GOOGLE_ACCOUNT.md`
- `backend/test/app.e2e-spec.ts`
- `backend/test/bullmq.e2e-spec.ts`
- `backend/test/jest-e2e.json`
- `backend/test/tsconfig.json`

**Insight**:
### AST & CFG ARCHITECTURAL ANALYSIS

**1. SYSTEM INFRASTRUCTURE & DEPLOYMENT TOPOLOGY**
*   **Runtime Environment**: Node.js (v22+ implied by `@types/node`).
*   **Orchestration**: Docker Compose.
    *   **Services**: `core` (API), `worker` (Background Jobs), `db` (Postgres 16), `redis` (Redis 7), `localstack` (AWS SQS emulation).
    *   **Volume Mounting**: Monorepo structure detected (`../../` context in `compose-backup.yaml`).
*   **Entry Points**:
    *   `main.ts`: HTTP API & WebSocket Gateway.
    *   `worker.ts`: Standalone BullMQ Worker process.
*   **Cloud Abstraction**:
    *   **AWS**: Localstack used for SQS (`live-chat-events.fifo`).
    *   **Mail**: SMTP via Nodemailer (supports Gmail/SES).

**2. CONFIGURATION & BUILD PIPELINE**
*   **TypeScript Configuration**:
    *   **Strictness**: Mixed. `strictNullChecks: true` is good, but `noImplicitAny: false` is a **Critical Weakness**, allowing untyped variables to propagate through the system.
    *   **Build**: `nest build` for API, separate target `build:worker` for the worker process.
*   **Linter**: ESLint with Flat Config (`eslint.config.mjs`).
    *   **Policy**: Explicitly disables `@typescript-eslint/no-explicit-any`, validating the extensive use of `any` observed in previous batches.
*   **Environment**: `ConfigModule` loads `.env`.
    *   **Secrets**: `.env.example` exposes structure for JWT secrets, Google OAuth, and Encryption keys.

**3. TESTING STRATEGY**
*   **Framework**: Jest + Supertest.
*   **Scope**:
    *   **Unit**: `*.spec.ts` (Standard NestJS).
    *   **E2E**: `test/*.e2e-spec.ts`.
*   **Integration Logic (`bullmq.e2e-spec.ts`)**:
    *   **Flow**: Emits `visitor.message.received` -> `InboxEventHandler` -> `BullMqProducer` -> Redis -> `EventProcessor` -> `EventConsumerService`.
    *   **Mechanism**: Overrides `EventConsumerService` with a mock to verify the async loop completes.
    *   **Flakiness**: Relies on `setTimeout(3000)` to wait for the worker, which is non-deterministic and prone to CI failures.

**4. ANALYSIS KERNEL**

*   **State Ownership**:
    *   **Infrastructure State**: Defined in `compose.yaml`. The application is stateless, relying on external persistence (Postgres/Redis).
    *   **Local Development**: `localstack-init` script owns the initial state of AWS resources (creating the SQS queue).

*   **Mutation Risk**:
    *   **Schema Management**: `package.json` scripts (`migration:generate`, `migration:run`) execute directly against the source (`src/database/data-source.ts`) using `tsx`. This is convenient but risks running dev-time logic in prod if not carefully separated in the build artifact.
    *   **Type Safety**: The combination of `noImplicitAny: false` in `tsconfig` and `no-explicit-any: off` in `eslint` creates a systemic risk of runtime type errors that the compiler ignores.

*   **Coupling & Cohesion**:
    *   **Monorepo Coupling**: `package.json` references local file dependencies (`file:../shared-dtos`, `file:../shared-types`), indicating tight coupling with sibling packages.
    *   **Infrastructure Coupling**: The backend code is coupled to specific AWS SQS attributes (FIFO) defined in the `init-aws.sh` script.

*** LENS: ENTROPY REDUCTION ***

**[REFACTORING CANDIDATES]**

1.  **[Critical/Type Safety]** - `backend/tsconfig.json`: `noImplicitAny: false` -> **Strategy**: Set to `true`. This will break the build initially but is necessary to identify and fix the "Leaky Abstractions" where `any` is passed around (e.g., Event payloads, JSON blobs).
2.  **[Critical/Linting]** - `backend/eslint.config.mjs`: `rules: { '@typescript-eslint/no-explicit-any': 'off' }` -> **Strategy**: Remove this override or set to `warn`. Enforce strict typing to prevent runtime crashes.
3.  **[Test Stability]** - `backend/test/bullmq.e2e-spec.ts`: `await new Promise((resolve) => setTimeout(resolve, 3000))` -> **Strategy**: Replace with a polling mechanism or a `waitForExpect` utility that checks the mock call repeatedly until timeout. Hardcoded sleeps are the primary cause of flaky CI pipelines.
4.  **[Infrastructure/Bloat]** - `backend/aws/install` & `backend/aws/dist/*` -> **Strategy**: **Delete**. Do not commit binary installers or 3rd party scripts to the repo. Use a Docker image that already has AWS CLI installed, or install it via `apk/apt` in the Dockerfile.
5.  **[Security/Secrets]** - `backend/compose-backup.yaml`: Hardcoded secrets (e.g., `JWT_SECRET: your_super_secret_jwt_key`) -> **Strategy**: Use `${VARIABLE}` syntax for all sensitive values and ensure they are populated from the host environment or a `.env` file, even in backup/example compose files.
6.  **[Build/Optimization]** - `backend/package.json`: `migration:generate` uses `tsx` on source files -> **Strategy**: Ensure migrations are compiled to JS for production use. Running `tsx` in production (if that's the plan for migrations) adds unnecessary overhead and dependencies.

---

